{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#symbolic-regressionequation-discovery-toolkit","title":"Symbolic Regression/Equation Discovery Toolkit","text":"<p>Documentation: https://smeznar.github.io/SymbolicRegressionToolkit</p> <p>This repository provides a Python-based toolkit for equation discovery/symbolic regression. Currently, the toolkit contains code for transforming infix expressions into trees, parameter estimation, and performance evaluation for symbolic regression models.</p> <p>Currently, we only support (vanilla) mathematical expressions, however, we provide a simple interface for adding custom symbols. In the future, we might extend our functionality to support more advanced expressions (differential equations, PDEs, ...).</p> <p>A simple example of how to use the toolkit can be found in the <code>examples</code> folder. Script <code>examples/SR_evaluation_minimal_example.py</code> contains a minimal example of how to use the toolkit for evaluating Symbolic Regression models. Script <code>examples/parameter_estimation_minimal_example.py</code> contains a minimal example of how to use the toolkit for parameter estimation. Lastly, script <code>examples/customization.py</code> shows how we can customize various parts of the toolkit and create executable python functions from infix expressions.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the package, run the following command in your terminal: <pre><code>pip install symbolic-regression-toolkit\n</code></pre></p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! If you'd like to contribute to the project, please submit a pull request with a clear description of your changes.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#symbolicregressiontoolkit-111-tba","title":"SymbolicRegressionToolkit-1.1.1 (TBA)","text":"<ul> <li>Updated documentation</li> <li>Added the change log</li> </ul> <p>New Features:</p> <ul> <li>Added Datasets</li> </ul>"},{"location":"changelog/#symbolicregressiontoolkit-110-2024-12-10","title":"SymbolicRegressionToolkit-1.1.0 (2024-12-10)","text":"<ul> <li>Project restructure</li> </ul> <p>New Features:</p> <ul> <li>Added documentation</li> <li>Expanded upon examples</li> </ul>"},{"location":"changelog/#symbolicregressiontoolkit-100-2024-12-06","title":"SymbolicRegressionToolkit-1.0.0 (2024-12-06)","text":"<ul> <li>Initial release</li> <li>Expression compilation</li> <li>Parameter estimation</li> <li>Model evaluation</li> <li>Examples for parameter estimation and performance evaluation</li> </ul>"},{"location":"references/","title":"Symbolic Regression Toolkit Module","text":""},{"location":"references/#SRToolkit","title":"<code>SRToolkit</code>","text":"<p>Symbolic Regression Toolkit</p> <p>This package provides a Python-based toolkit for equation discovery/symbolic regression.</p> <p>Modules:</p> Name Description <code>utils</code> <p>The module containing utility classes and functions.</p> <code>evaluation</code> <p>The module containing classes and functions for estimating parameters and evaluating Symbolic Regression models.</p>"},{"location":"references/dataset/","title":"Dataset Module","text":""},{"location":"references/dataset/#SRToolkit.dataset","title":"<code>SRToolkit.dataset</code>","text":"<p>This module contains data sets</p>"},{"location":"references/dataset/#SRToolkit.dataset.SRDataset","title":"<code>SRDataset</code>","text":"Source code in <code>SRToolkit/dataset/srdataset.py</code> <pre><code>class SRDataset:\n    def __init__(self, X: np.ndarray, y: np.ndarray, ground_truth: List[str], original_equation: str,\n                 symbols: SymbolLibrary, max_evaluations: int=-1, max_expression_length: int=-1, max_constants: int=8,\n                 success_threshold: float=1e-7, constant_range: List[float]=None, dataset_metadata: dict=None):\n        \"\"\"\n        Initializes an instance of the SRDataset class.\n\n        Args:\n            X: The input data to be used in parameter estimation for variables. We assume that X is a 2D array\n                with shape (n_samples, n_features).\n            y: The target values to be used in parameter estimation.\n            ground_truth: The ground truth expression, represented as a list of tokens (strings) in the infix notation.\n            original_equation: The original equation from which the ground truth expression was generated).\n            symbols: The symbol library to use.\n            max_evaluations: The maximum number of expressions to evaluate. Less than 0 means no limit.\n            max_expression_length: The maximum length of the expression. Less than 0 means no limit.\n            max_constants: The maximum number of constants allowed in the expression. Less than 0 means no limit.\n            success_threshold: The RMSE threshold below which the experiment is considered successful.\n            constant_range: A list of two floats, specifying the lower and upper bounds for the constant values.\n                Default is [-5.0, 5.0]. If constant_range is None, we automatically set it to [-5.0, 5.0]\n                if the symbol library contains a symbol for constants.\n            dataset_metadata: An optional dictionary containing metadata about this evaluation. This could include\n                information such as the name of the dataset, a citation for the dataset, number of variables, etc.\n        \"\"\"\n        self.X = X\n        self.y = y\n        self.ground_truth = \"\".join(ground_truth)\n        self.original_equation = original_equation\n\n        self.max_evaluations = max_evaluations\n        self.max_expression_length = max_expression_length\n        self.max_constants = max_constants\n\n        self.success_threshold = success_threshold\n\n        self.symbols = symbols\n\n        # See if symbols contain a symbol for constants\n        symbols_metadata = self.symbols.symbols.values()\n        self.contains_constants = any([symbol[\"type\"] == \"const\" for symbol in symbols_metadata])\n        if constant_range is None and self.contains_constants:\n            constant_range = [-5.0, 5.0]\n        self.constant_range = constant_range\n\n        self.dataset_metadata = dataset_metadata\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a string describing this dataset.\n\n        The string describes the target expression, symbols that should be used,\n        and the success threshold. It also includes any constraints that should\n        be followed when evaluating a model on this dataset, such as the maximum\n        number of expressions to evaluate, the maximum length of the expression,\n        and the maximum number of constants allowed in the expression. If the\n        symbol library contains a symbol for constants, the string also includes\n        the range of constants.\n\n        For other metadata, please refer to the attribute self.dataset_metadata.\n\n        Returns:\n            A string describing this dataset.\n        \"\"\"\n        description = f\"Dataset for target expression {self.ground_truth}. \"\n        description += (f\" When evaluating your model on this dataset, you should limit your generative model to only\"\n                        f\" produce expressions using the following symbols: {str(self.symbols)}. Expressions are deemed\"\n                        f\" successful if the root mean squared error is less than {self.success_threshold}. However, we\"\n                        f\" advise that you check the best performing expressions manually to ensure they are correct.\")\n\n        has_limitations = False\n        limitations = \"Constraints for this dataset are:\"\n        if self.max_evaluations &gt; 0:\n            has_limitations = True\n            limitations += f\" max_evaluations={self.max_evaluations}, \"\n        if self.max_expression_length &gt; 0:\n            has_limitations = True\n            limitations += f\" max_expression_length={self.max_expression_length}, \"\n        if self.max_constants &gt; 0:\n            has_limitations = True\n            limitations += f\" max_constants={self.max_constants}, \"\n\n        if has_limitations:\n            limitations = limitations[:-2] + \".\"\n            description += limitations\n\n        if self.contains_constants:\n            description += f\" The dataset contains constants. The range of constants is {self.constant_range}.\"\n\n        description += \"For other metadata, please refer to the attribute self.dataset_metadata.\"\n\n        return description\n\n    def create_evaluator(self, metadata: dict=None) -&gt; SR_evaluator:\n        \"\"\"\n        Creates an instance of the SR_evaluator class from this dataset.\n\n        Args:\n            metadata: An optional dictionary containing metadata about this evaluation. This could include\n                information such as the dataset used, the model used, seed, etc.\n\n        Returns:\n            An instance of the SR_evaluator class.\n        \"\"\"\n        if metadata is None:\n            metadata = dict()\n        metadata[\"dataset_metadata\"] = self.dataset_metadata\n        return SR_evaluator(self.X, self.y, max_evaluations=self.max_evaluations, metadata=metadata,\n                            symbol_library=self.symbols, max_constants=self.max_constants,\n                            max_expression_length=self.max_expression_length,)\n</code></pre>"},{"location":"references/dataset/#SRToolkit.dataset.SRDataset.__init__","title":"<code>__init__(X, y, ground_truth, original_equation, symbols, max_evaluations=-1, max_expression_length=-1, max_constants=8, success_threshold=1e-07, constant_range=None, dataset_metadata=None)</code>","text":"<p>Initializes an instance of the SRDataset class.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>The input data to be used in parameter estimation for variables. We assume that X is a 2D array with shape (n_samples, n_features).</p> required <code>y</code> <code>ndarray</code> <p>The target values to be used in parameter estimation.</p> required <code>ground_truth</code> <code>List[str]</code> <p>The ground truth expression, represented as a list of tokens (strings) in the infix notation.</p> required <code>original_equation</code> <code>str</code> <p>The original equation from which the ground truth expression was generated).</p> required <code>symbols</code> <code>SymbolLibrary</code> <p>The symbol library to use.</p> required <code>max_evaluations</code> <code>int</code> <p>The maximum number of expressions to evaluate. Less than 0 means no limit.</p> <code>-1</code> <code>max_expression_length</code> <code>int</code> <p>The maximum length of the expression. Less than 0 means no limit.</p> <code>-1</code> <code>max_constants</code> <code>int</code> <p>The maximum number of constants allowed in the expression. Less than 0 means no limit.</p> <code>8</code> <code>success_threshold</code> <code>float</code> <p>The RMSE threshold below which the experiment is considered successful.</p> <code>1e-07</code> <code>constant_range</code> <code>List[float]</code> <p>A list of two floats, specifying the lower and upper bounds for the constant values. Default is [-5.0, 5.0]. If constant_range is None, we automatically set it to [-5.0, 5.0] if the symbol library contains a symbol for constants.</p> <code>None</code> <code>dataset_metadata</code> <code>dict</code> <p>An optional dictionary containing metadata about this evaluation. This could include information such as the name of the dataset, a citation for the dataset, number of variables, etc.</p> <code>None</code> Source code in <code>SRToolkit/dataset/srdataset.py</code> <pre><code>def __init__(self, X: np.ndarray, y: np.ndarray, ground_truth: List[str], original_equation: str,\n             symbols: SymbolLibrary, max_evaluations: int=-1, max_expression_length: int=-1, max_constants: int=8,\n             success_threshold: float=1e-7, constant_range: List[float]=None, dataset_metadata: dict=None):\n    \"\"\"\n    Initializes an instance of the SRDataset class.\n\n    Args:\n        X: The input data to be used in parameter estimation for variables. We assume that X is a 2D array\n            with shape (n_samples, n_features).\n        y: The target values to be used in parameter estimation.\n        ground_truth: The ground truth expression, represented as a list of tokens (strings) in the infix notation.\n        original_equation: The original equation from which the ground truth expression was generated).\n        symbols: The symbol library to use.\n        max_evaluations: The maximum number of expressions to evaluate. Less than 0 means no limit.\n        max_expression_length: The maximum length of the expression. Less than 0 means no limit.\n        max_constants: The maximum number of constants allowed in the expression. Less than 0 means no limit.\n        success_threshold: The RMSE threshold below which the experiment is considered successful.\n        constant_range: A list of two floats, specifying the lower and upper bounds for the constant values.\n            Default is [-5.0, 5.0]. If constant_range is None, we automatically set it to [-5.0, 5.0]\n            if the symbol library contains a symbol for constants.\n        dataset_metadata: An optional dictionary containing metadata about this evaluation. This could include\n            information such as the name of the dataset, a citation for the dataset, number of variables, etc.\n    \"\"\"\n    self.X = X\n    self.y = y\n    self.ground_truth = \"\".join(ground_truth)\n    self.original_equation = original_equation\n\n    self.max_evaluations = max_evaluations\n    self.max_expression_length = max_expression_length\n    self.max_constants = max_constants\n\n    self.success_threshold = success_threshold\n\n    self.symbols = symbols\n\n    # See if symbols contain a symbol for constants\n    symbols_metadata = self.symbols.symbols.values()\n    self.contains_constants = any([symbol[\"type\"] == \"const\" for symbol in symbols_metadata])\n    if constant_range is None and self.contains_constants:\n        constant_range = [-5.0, 5.0]\n    self.constant_range = constant_range\n\n    self.dataset_metadata = dataset_metadata\n</code></pre>"},{"location":"references/dataset/#SRToolkit.dataset.SRDataset.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string describing this dataset.</p> <p>The string describes the target expression, symbols that should be used, and the success threshold. It also includes any constraints that should be followed when evaluating a model on this dataset, such as the maximum number of expressions to evaluate, the maximum length of the expression, and the maximum number of constants allowed in the expression. If the symbol library contains a symbol for constants, the string also includes the range of constants.</p> <p>For other metadata, please refer to the attribute self.dataset_metadata.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string describing this dataset.</p> Source code in <code>SRToolkit/dataset/srdataset.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a string describing this dataset.\n\n    The string describes the target expression, symbols that should be used,\n    and the success threshold. It also includes any constraints that should\n    be followed when evaluating a model on this dataset, such as the maximum\n    number of expressions to evaluate, the maximum length of the expression,\n    and the maximum number of constants allowed in the expression. If the\n    symbol library contains a symbol for constants, the string also includes\n    the range of constants.\n\n    For other metadata, please refer to the attribute self.dataset_metadata.\n\n    Returns:\n        A string describing this dataset.\n    \"\"\"\n    description = f\"Dataset for target expression {self.ground_truth}. \"\n    description += (f\" When evaluating your model on this dataset, you should limit your generative model to only\"\n                    f\" produce expressions using the following symbols: {str(self.symbols)}. Expressions are deemed\"\n                    f\" successful if the root mean squared error is less than {self.success_threshold}. However, we\"\n                    f\" advise that you check the best performing expressions manually to ensure they are correct.\")\n\n    has_limitations = False\n    limitations = \"Constraints for this dataset are:\"\n    if self.max_evaluations &gt; 0:\n        has_limitations = True\n        limitations += f\" max_evaluations={self.max_evaluations}, \"\n    if self.max_expression_length &gt; 0:\n        has_limitations = True\n        limitations += f\" max_expression_length={self.max_expression_length}, \"\n    if self.max_constants &gt; 0:\n        has_limitations = True\n        limitations += f\" max_constants={self.max_constants}, \"\n\n    if has_limitations:\n        limitations = limitations[:-2] + \".\"\n        description += limitations\n\n    if self.contains_constants:\n        description += f\" The dataset contains constants. The range of constants is {self.constant_range}.\"\n\n    description += \"For other metadata, please refer to the attribute self.dataset_metadata.\"\n\n    return description\n</code></pre>"},{"location":"references/dataset/#SRToolkit.dataset.SRDataset.create_evaluator","title":"<code>create_evaluator(metadata=None)</code>","text":"<p>Creates an instance of the SR_evaluator class from this dataset.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>An optional dictionary containing metadata about this evaluation. This could include information such as the dataset used, the model used, seed, etc.</p> <code>None</code> <p>Returns:</p> Type Description <code>SR_evaluator</code> <p>An instance of the SR_evaluator class.</p> Source code in <code>SRToolkit/dataset/srdataset.py</code> <pre><code>def create_evaluator(self, metadata: dict=None) -&gt; SR_evaluator:\n    \"\"\"\n    Creates an instance of the SR_evaluator class from this dataset.\n\n    Args:\n        metadata: An optional dictionary containing metadata about this evaluation. This could include\n            information such as the dataset used, the model used, seed, etc.\n\n    Returns:\n        An instance of the SR_evaluator class.\n    \"\"\"\n    if metadata is None:\n        metadata = dict()\n    metadata[\"dataset_metadata\"] = self.dataset_metadata\n    return SR_evaluator(self.X, self.y, max_evaluations=self.max_evaluations, metadata=metadata,\n                        symbol_library=self.symbols, max_constants=self.max_constants,\n                        max_expression_length=self.max_expression_length,)\n</code></pre>"},{"location":"references/dataset/srdataset/","title":"SRDataset Module","text":""},{"location":"references/dataset/srdataset/#SRToolkit.dataset.srdataset","title":"<code>SRToolkit.dataset.srdataset</code>","text":""},{"location":"references/dataset/srdataset/#SRToolkit.dataset.srdataset.SRDataset","title":"<code>SRDataset</code>","text":"Source code in <code>SRToolkit/dataset/srdataset.py</code> <pre><code>class SRDataset:\n    def __init__(self, X: np.ndarray, y: np.ndarray, ground_truth: List[str], original_equation: str,\n                 symbols: SymbolLibrary, max_evaluations: int=-1, max_expression_length: int=-1, max_constants: int=8,\n                 success_threshold: float=1e-7, constant_range: List[float]=None, dataset_metadata: dict=None):\n        \"\"\"\n        Initializes an instance of the SRDataset class.\n\n        Args:\n            X: The input data to be used in parameter estimation for variables. We assume that X is a 2D array\n                with shape (n_samples, n_features).\n            y: The target values to be used in parameter estimation.\n            ground_truth: The ground truth expression, represented as a list of tokens (strings) in the infix notation.\n            original_equation: The original equation from which the ground truth expression was generated).\n            symbols: The symbol library to use.\n            max_evaluations: The maximum number of expressions to evaluate. Less than 0 means no limit.\n            max_expression_length: The maximum length of the expression. Less than 0 means no limit.\n            max_constants: The maximum number of constants allowed in the expression. Less than 0 means no limit.\n            success_threshold: The RMSE threshold below which the experiment is considered successful.\n            constant_range: A list of two floats, specifying the lower and upper bounds for the constant values.\n                Default is [-5.0, 5.0]. If constant_range is None, we automatically set it to [-5.0, 5.0]\n                if the symbol library contains a symbol for constants.\n            dataset_metadata: An optional dictionary containing metadata about this evaluation. This could include\n                information such as the name of the dataset, a citation for the dataset, number of variables, etc.\n        \"\"\"\n        self.X = X\n        self.y = y\n        self.ground_truth = \"\".join(ground_truth)\n        self.original_equation = original_equation\n\n        self.max_evaluations = max_evaluations\n        self.max_expression_length = max_expression_length\n        self.max_constants = max_constants\n\n        self.success_threshold = success_threshold\n\n        self.symbols = symbols\n\n        # See if symbols contain a symbol for constants\n        symbols_metadata = self.symbols.symbols.values()\n        self.contains_constants = any([symbol[\"type\"] == \"const\" for symbol in symbols_metadata])\n        if constant_range is None and self.contains_constants:\n            constant_range = [-5.0, 5.0]\n        self.constant_range = constant_range\n\n        self.dataset_metadata = dataset_metadata\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a string describing this dataset.\n\n        The string describes the target expression, symbols that should be used,\n        and the success threshold. It also includes any constraints that should\n        be followed when evaluating a model on this dataset, such as the maximum\n        number of expressions to evaluate, the maximum length of the expression,\n        and the maximum number of constants allowed in the expression. If the\n        symbol library contains a symbol for constants, the string also includes\n        the range of constants.\n\n        For other metadata, please refer to the attribute self.dataset_metadata.\n\n        Returns:\n            A string describing this dataset.\n        \"\"\"\n        description = f\"Dataset for target expression {self.ground_truth}. \"\n        description += (f\" When evaluating your model on this dataset, you should limit your generative model to only\"\n                        f\" produce expressions using the following symbols: {str(self.symbols)}. Expressions are deemed\"\n                        f\" successful if the root mean squared error is less than {self.success_threshold}. However, we\"\n                        f\" advise that you check the best performing expressions manually to ensure they are correct.\")\n\n        has_limitations = False\n        limitations = \"Constraints for this dataset are:\"\n        if self.max_evaluations &gt; 0:\n            has_limitations = True\n            limitations += f\" max_evaluations={self.max_evaluations}, \"\n        if self.max_expression_length &gt; 0:\n            has_limitations = True\n            limitations += f\" max_expression_length={self.max_expression_length}, \"\n        if self.max_constants &gt; 0:\n            has_limitations = True\n            limitations += f\" max_constants={self.max_constants}, \"\n\n        if has_limitations:\n            limitations = limitations[:-2] + \".\"\n            description += limitations\n\n        if self.contains_constants:\n            description += f\" The dataset contains constants. The range of constants is {self.constant_range}.\"\n\n        description += \"For other metadata, please refer to the attribute self.dataset_metadata.\"\n\n        return description\n\n    def create_evaluator(self, metadata: dict=None) -&gt; SR_evaluator:\n        \"\"\"\n        Creates an instance of the SR_evaluator class from this dataset.\n\n        Args:\n            metadata: An optional dictionary containing metadata about this evaluation. This could include\n                information such as the dataset used, the model used, seed, etc.\n\n        Returns:\n            An instance of the SR_evaluator class.\n        \"\"\"\n        if metadata is None:\n            metadata = dict()\n        metadata[\"dataset_metadata\"] = self.dataset_metadata\n        return SR_evaluator(self.X, self.y, max_evaluations=self.max_evaluations, metadata=metadata,\n                            symbol_library=self.symbols, max_constants=self.max_constants,\n                            max_expression_length=self.max_expression_length,)\n</code></pre>"},{"location":"references/dataset/srdataset/#SRToolkit.dataset.srdataset.SRDataset.__init__","title":"<code>__init__(X, y, ground_truth, original_equation, symbols, max_evaluations=-1, max_expression_length=-1, max_constants=8, success_threshold=1e-07, constant_range=None, dataset_metadata=None)</code>","text":"<p>Initializes an instance of the SRDataset class.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>The input data to be used in parameter estimation for variables. We assume that X is a 2D array with shape (n_samples, n_features).</p> required <code>y</code> <code>ndarray</code> <p>The target values to be used in parameter estimation.</p> required <code>ground_truth</code> <code>List[str]</code> <p>The ground truth expression, represented as a list of tokens (strings) in the infix notation.</p> required <code>original_equation</code> <code>str</code> <p>The original equation from which the ground truth expression was generated).</p> required <code>symbols</code> <code>SymbolLibrary</code> <p>The symbol library to use.</p> required <code>max_evaluations</code> <code>int</code> <p>The maximum number of expressions to evaluate. Less than 0 means no limit.</p> <code>-1</code> <code>max_expression_length</code> <code>int</code> <p>The maximum length of the expression. Less than 0 means no limit.</p> <code>-1</code> <code>max_constants</code> <code>int</code> <p>The maximum number of constants allowed in the expression. Less than 0 means no limit.</p> <code>8</code> <code>success_threshold</code> <code>float</code> <p>The RMSE threshold below which the experiment is considered successful.</p> <code>1e-07</code> <code>constant_range</code> <code>List[float]</code> <p>A list of two floats, specifying the lower and upper bounds for the constant values. Default is [-5.0, 5.0]. If constant_range is None, we automatically set it to [-5.0, 5.0] if the symbol library contains a symbol for constants.</p> <code>None</code> <code>dataset_metadata</code> <code>dict</code> <p>An optional dictionary containing metadata about this evaluation. This could include information such as the name of the dataset, a citation for the dataset, number of variables, etc.</p> <code>None</code> Source code in <code>SRToolkit/dataset/srdataset.py</code> <pre><code>def __init__(self, X: np.ndarray, y: np.ndarray, ground_truth: List[str], original_equation: str,\n             symbols: SymbolLibrary, max_evaluations: int=-1, max_expression_length: int=-1, max_constants: int=8,\n             success_threshold: float=1e-7, constant_range: List[float]=None, dataset_metadata: dict=None):\n    \"\"\"\n    Initializes an instance of the SRDataset class.\n\n    Args:\n        X: The input data to be used in parameter estimation for variables. We assume that X is a 2D array\n            with shape (n_samples, n_features).\n        y: The target values to be used in parameter estimation.\n        ground_truth: The ground truth expression, represented as a list of tokens (strings) in the infix notation.\n        original_equation: The original equation from which the ground truth expression was generated).\n        symbols: The symbol library to use.\n        max_evaluations: The maximum number of expressions to evaluate. Less than 0 means no limit.\n        max_expression_length: The maximum length of the expression. Less than 0 means no limit.\n        max_constants: The maximum number of constants allowed in the expression. Less than 0 means no limit.\n        success_threshold: The RMSE threshold below which the experiment is considered successful.\n        constant_range: A list of two floats, specifying the lower and upper bounds for the constant values.\n            Default is [-5.0, 5.0]. If constant_range is None, we automatically set it to [-5.0, 5.0]\n            if the symbol library contains a symbol for constants.\n        dataset_metadata: An optional dictionary containing metadata about this evaluation. This could include\n            information such as the name of the dataset, a citation for the dataset, number of variables, etc.\n    \"\"\"\n    self.X = X\n    self.y = y\n    self.ground_truth = \"\".join(ground_truth)\n    self.original_equation = original_equation\n\n    self.max_evaluations = max_evaluations\n    self.max_expression_length = max_expression_length\n    self.max_constants = max_constants\n\n    self.success_threshold = success_threshold\n\n    self.symbols = symbols\n\n    # See if symbols contain a symbol for constants\n    symbols_metadata = self.symbols.symbols.values()\n    self.contains_constants = any([symbol[\"type\"] == \"const\" for symbol in symbols_metadata])\n    if constant_range is None and self.contains_constants:\n        constant_range = [-5.0, 5.0]\n    self.constant_range = constant_range\n\n    self.dataset_metadata = dataset_metadata\n</code></pre>"},{"location":"references/dataset/srdataset/#SRToolkit.dataset.srdataset.SRDataset.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string describing this dataset.</p> <p>The string describes the target expression, symbols that should be used, and the success threshold. It also includes any constraints that should be followed when evaluating a model on this dataset, such as the maximum number of expressions to evaluate, the maximum length of the expression, and the maximum number of constants allowed in the expression. If the symbol library contains a symbol for constants, the string also includes the range of constants.</p> <p>For other metadata, please refer to the attribute self.dataset_metadata.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string describing this dataset.</p> Source code in <code>SRToolkit/dataset/srdataset.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a string describing this dataset.\n\n    The string describes the target expression, symbols that should be used,\n    and the success threshold. It also includes any constraints that should\n    be followed when evaluating a model on this dataset, such as the maximum\n    number of expressions to evaluate, the maximum length of the expression,\n    and the maximum number of constants allowed in the expression. If the\n    symbol library contains a symbol for constants, the string also includes\n    the range of constants.\n\n    For other metadata, please refer to the attribute self.dataset_metadata.\n\n    Returns:\n        A string describing this dataset.\n    \"\"\"\n    description = f\"Dataset for target expression {self.ground_truth}. \"\n    description += (f\" When evaluating your model on this dataset, you should limit your generative model to only\"\n                    f\" produce expressions using the following symbols: {str(self.symbols)}. Expressions are deemed\"\n                    f\" successful if the root mean squared error is less than {self.success_threshold}. However, we\"\n                    f\" advise that you check the best performing expressions manually to ensure they are correct.\")\n\n    has_limitations = False\n    limitations = \"Constraints for this dataset are:\"\n    if self.max_evaluations &gt; 0:\n        has_limitations = True\n        limitations += f\" max_evaluations={self.max_evaluations}, \"\n    if self.max_expression_length &gt; 0:\n        has_limitations = True\n        limitations += f\" max_expression_length={self.max_expression_length}, \"\n    if self.max_constants &gt; 0:\n        has_limitations = True\n        limitations += f\" max_constants={self.max_constants}, \"\n\n    if has_limitations:\n        limitations = limitations[:-2] + \".\"\n        description += limitations\n\n    if self.contains_constants:\n        description += f\" The dataset contains constants. The range of constants is {self.constant_range}.\"\n\n    description += \"For other metadata, please refer to the attribute self.dataset_metadata.\"\n\n    return description\n</code></pre>"},{"location":"references/dataset/srdataset/#SRToolkit.dataset.srdataset.SRDataset.create_evaluator","title":"<code>create_evaluator(metadata=None)</code>","text":"<p>Creates an instance of the SR_evaluator class from this dataset.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>An optional dictionary containing metadata about this evaluation. This could include information such as the dataset used, the model used, seed, etc.</p> <code>None</code> <p>Returns:</p> Type Description <code>SR_evaluator</code> <p>An instance of the SR_evaluator class.</p> Source code in <code>SRToolkit/dataset/srdataset.py</code> <pre><code>def create_evaluator(self, metadata: dict=None) -&gt; SR_evaluator:\n    \"\"\"\n    Creates an instance of the SR_evaluator class from this dataset.\n\n    Args:\n        metadata: An optional dictionary containing metadata about this evaluation. This could include\n            information such as the dataset used, the model used, seed, etc.\n\n    Returns:\n        An instance of the SR_evaluator class.\n    \"\"\"\n    if metadata is None:\n        metadata = dict()\n    metadata[\"dataset_metadata\"] = self.dataset_metadata\n    return SR_evaluator(self.X, self.y, max_evaluations=self.max_evaluations, metadata=metadata,\n                        symbol_library=self.symbols, max_constants=self.max_constants,\n                        max_expression_length=self.max_expression_length,)\n</code></pre>"},{"location":"references/evaluation/","title":"Evaluation Module","text":""},{"location":"references/evaluation/#SRToolkit.evaluation","title":"<code>SRToolkit.evaluation</code>","text":"<p>This module contains classes and functions for evaluating symbolic regression approaches. Mainly it contains classes that can be used for parameter estimation and evaluation of mathematical expressions on some dataset.</p> <p>Modules:</p> Name Description <code>parameter_estimator</code> <p>The module containing classes and functions for parameter estimation.</p> <code>sr_evaluator</code> <p>The module containing classes and functions for expressions on some dataset.</p>"},{"location":"references/evaluation/#SRToolkit.evaluation.ParameterEstimator","title":"<code>ParameterEstimator</code>","text":"Source code in <code>SRToolkit/evaluation/parameter_estimator.py</code> <pre><code>class ParameterEstimator:\n    def __init__(self, X: np.ndarray, y: np.ndarray, symbol_library: SymbolLibrary=SymbolLibrary.default_symbols(), **kwargs):\n        \"\"\"\n        Initializes an instance of the ParameterEstimator class.\n\n        Examples:\n            &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n            &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n            &gt;&gt;&gt; pe = ParameterEstimator(X, y)\n            &gt;&gt;&gt; rmse, constants = pe.estimate_parameters([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n            &gt;&gt;&gt; print(rmse &lt; 1e-6)\n            True\n            &gt;&gt;&gt; print(1.99 &lt; constants[0] &lt; 2.01)\n            True\n\n        Args:\n            X: The input data to be used in parameter estimation for variables. We assume that X is a 2D array\n                with shape (n_samples, n_features).\n            y: The target values to be used in parameter estimation.\n            symbol_library: The symbol library to use. Defaults to SymbolLibrary.default_symbols().\n\n        Keyword Arguments:\n            method str: The method to be used for minimization. Currently, only \"L-BFGS-B\" is supported/tested. Default is \"L-BFGS-B\".\n            tol float: The tolerance for termination. Default is 1e-6.\n            gtol float: The tolerance for the gradient norm. Default is 1e-3.\n            max_iter int: The maximum number of iterations. Default is 100.\n            bounds List[float]: A list of two elements, specifying the lower and upper bounds for the constant values. Default is [-5, 5].\n            initialization str: The method to use for initializing the constant values. Currently, only \"random\" and \"mean\" are supported. \"random\" creates a vector with random values\n                                sampled within the bounds. \"mean\" creates a vector where all values are calculated as (lower_bound + upper_bound)/2. Default is \"random\".\n            max_constants int: The maximum number of constants allowed in the expression. Default is 8.\n            max_expr_length int: The maximum length of the expression. Default is -1 (no limit).\n\n        Methods:\n            estimate_parameters(expr: List[str]): Estimates the parameters of an expression by minimizing the error between the predicted and actual values.\n        \"\"\"\n        self.symbol_library = symbol_library\n        self.X = X\n        self.y = y\n        # self.stats = {\"success\": 0, \"failure\": 0, \"steps\": dict(), \"num_constants\": dict(), \"failed_constants\": dict()}\n\n        self.estimation_settings = {\n                \"method\": \"L-BFGS-B\",\n                \"tol\": 1e-6,\n                \"gtol\": 1e-3,\n                \"max_iter\": 100,\n                \"bounds\": [-5, 5],\n                \"initialization\": \"random\", # random, mean\n                \"max_constants\": 8,\n                \"max_expr_length\": -1\n        }\n\n        if kwargs:\n            self.estimation_settings.update(kwargs)\n\n    def estimate_parameters(self, expr: List[str]) -&gt; Tuple[float, np.ndarray]:\n        \"\"\"\n        Estimates the parameters of an expression by minimizing the error between the predicted and actual values.\n\n        Examples:\n            &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n            &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n            &gt;&gt;&gt; pe = ParameterEstimator(X, y)\n            &gt;&gt;&gt; rmse, constants = pe.estimate_parameters([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n            &gt;&gt;&gt; print(rmse &lt; 1e-6)\n            True\n            &gt;&gt;&gt; print(1.99 &lt; constants[0] &lt; 2.01)\n            True\n\n        Args:\n            expr: A list of strings representing the expression to be evaluated. The expression should include the\n                  symbol 'C' for constants whose values need to be estimated.\n\n        Returns:\n            the root mean square error (RMSE) of the optimized expression.\n            An array containing the optimized constant values.\n\n        Notes:\n            if the length of the expression exceeds the maximum allowed, NaN and an empty array are returned.\n            If the number of constants in the expression exceeds the maximum allowed, NaN and an empty array are returned.\n            If there are no constants in the expression, the RMSE is calculated directly without optimization.\n        \"\"\"\n        num_constants = sum([1 for t in expr if t == \"C\"])\n        if 0 &lt;= self.estimation_settings[\"max_constants\"] &lt; num_constants:\n            return np.nan, np.array([])\n\n        if 0 &lt;= self.estimation_settings[\"max_expr_length\"] &lt; len(expr):\n            return np.nan, np.array([])\n\n        executable_error_fn = expr_to_error_function(expr, self.symbol_library)\n\n        if num_constants == 0:\n            rmse = executable_error_fn(self.X, np.array([]), self.y)\n            return rmse, np.array([])\n        else:\n            return self._optimize_parameters(executable_error_fn, num_constants)\n\n    def _optimize_parameters(self, executable_error_fn: callable, num_constants: int) -&gt; Tuple[float, np.ndarray]:\n        \"\"\"\n        Optimizes the parameters of a given expression by minimizing the root mean squared error between the predicted and actual values.\n\n        Parameters\n        ----------\n        executable_error_fn : callable\n            A function that takes in the input values, the constant values, and the target values and returns the root mean squared error.\n        num_constants : int\n            The number of constants in the expression.\n\n        Returns\n        -------\n        float\n            The root mean square error of the optimized expression.\n        np.ndarray\n            An array containing the optimized constant values.\n        \"\"\"\n        if self.estimation_settings[\"initialization\"] == \"random\":\n            x0 = np.random.rand(num_constants) * (self.estimation_settings[\"bounds\"][1] - self.estimation_settings[\"bounds\"][0]) + self.estimation_settings[\"bounds\"][0]\n        else:\n            x0 = np.array([np.mean(self.estimation_settings[\"bounds\"]) for _ in range(num_constants)])\n\n        res = minimize(lambda c: executable_error_fn(self.X, c, self.y), x0, method=self.estimation_settings[\"method\"],\n                       tol=self.estimation_settings[\"tol\"],\n                       options={\n                           \"maxiter\": self.estimation_settings[\"max_iter\"],\n                           \"gtol\": self.estimation_settings[\"gtol\"]\n                                },\n                       bounds=[(self.estimation_settings[\"bounds\"][0], self.estimation_settings[\"bounds\"][1]) for _ in range(num_constants)])\n\n        # if res.success:\n        #     self.stats[\"success\"] += 1\n        # else:\n        #     self.stats[\"failure\"] += 1\n        #     if num_constants in self.stats[\"failed_constants\"]:\n        #         self.stats[\"failed_constants\"][num_constants] += 1\n        #     else:\n        #         self.stats[\"failed_constants\"][num_constants] = 1\n        #\n        # if res.nit in self.stats[\"steps\"]:\n        #     self.stats[\"steps\"][res.nit] += 1\n        # else:\n        #     self.stats[\"steps\"][res.nit] = 1\n        #\n        # if num_constants in self.stats[\"num_constants\"]:\n        #     self.stats[\"num_constants\"][num_constants] += 1\n        # else:\n        #     self.stats[\"num_constants\"][num_constants] = 1\n\n        return res.fun, res.x\n</code></pre>"},{"location":"references/evaluation/#SRToolkit.evaluation.ParameterEstimator.__init__","title":"<code>__init__(X, y, symbol_library=SymbolLibrary.default_symbols(), **kwargs)</code>","text":"<p>Initializes an instance of the ParameterEstimator class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n&gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n&gt;&gt;&gt; pe = ParameterEstimator(X, y)\n&gt;&gt;&gt; rmse, constants = pe.estimate_parameters([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n&gt;&gt;&gt; print(rmse &lt; 1e-6)\nTrue\n&gt;&gt;&gt; print(1.99 &lt; constants[0] &lt; 2.01)\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>The input data to be used in parameter estimation for variables. We assume that X is a 2D array with shape (n_samples, n_features).</p> required <code>y</code> <code>ndarray</code> <p>The target values to be used in parameter estimation.</p> required <code>symbol_library</code> <code>SymbolLibrary</code> <p>The symbol library to use. Defaults to SymbolLibrary.default_symbols().</p> <code>default_symbols()</code> <p>Other Parameters:</p> Name Type Description <code>method</code> <code>str</code> <p>The method to be used for minimization. Currently, only \"L-BFGS-B\" is supported/tested. Default is \"L-BFGS-B\".</p> <code>tol</code> <code>float</code> <p>The tolerance for termination. Default is 1e-6.</p> <code>gtol</code> <code>float</code> <p>The tolerance for the gradient norm. Default is 1e-3.</p> <code>max_iter</code> <code>int</code> <p>The maximum number of iterations. Default is 100.</p> <code>bounds</code> <code>List[float]</code> <p>A list of two elements, specifying the lower and upper bounds for the constant values. Default is [-5, 5].</p> <code>initialization</code> <code>str</code> <p>The method to use for initializing the constant values. Currently, only \"random\" and \"mean\" are supported. \"random\" creates a vector with random values                 sampled within the bounds. \"mean\" creates a vector where all values are calculated as (lower_bound + upper_bound)/2. Default is \"random\".</p> <code>max_constants</code> <code>int</code> <p>The maximum number of constants allowed in the expression. Default is 8.</p> <code>max_expr_length</code> <code>int</code> <p>The maximum length of the expression. Default is -1 (no limit).</p> <p>Functions:</p> Name Description <code>estimate_parameters</code> <p>List[str]): Estimates the parameters of an expression by minimizing the error between the predicted and actual values.</p> Source code in <code>SRToolkit/evaluation/parameter_estimator.py</code> <pre><code>def __init__(self, X: np.ndarray, y: np.ndarray, symbol_library: SymbolLibrary=SymbolLibrary.default_symbols(), **kwargs):\n    \"\"\"\n    Initializes an instance of the ParameterEstimator class.\n\n    Examples:\n        &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n        &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n        &gt;&gt;&gt; pe = ParameterEstimator(X, y)\n        &gt;&gt;&gt; rmse, constants = pe.estimate_parameters([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n        &gt;&gt;&gt; print(rmse &lt; 1e-6)\n        True\n        &gt;&gt;&gt; print(1.99 &lt; constants[0] &lt; 2.01)\n        True\n\n    Args:\n        X: The input data to be used in parameter estimation for variables. We assume that X is a 2D array\n            with shape (n_samples, n_features).\n        y: The target values to be used in parameter estimation.\n        symbol_library: The symbol library to use. Defaults to SymbolLibrary.default_symbols().\n\n    Keyword Arguments:\n        method str: The method to be used for minimization. Currently, only \"L-BFGS-B\" is supported/tested. Default is \"L-BFGS-B\".\n        tol float: The tolerance for termination. Default is 1e-6.\n        gtol float: The tolerance for the gradient norm. Default is 1e-3.\n        max_iter int: The maximum number of iterations. Default is 100.\n        bounds List[float]: A list of two elements, specifying the lower and upper bounds for the constant values. Default is [-5, 5].\n        initialization str: The method to use for initializing the constant values. Currently, only \"random\" and \"mean\" are supported. \"random\" creates a vector with random values\n                            sampled within the bounds. \"mean\" creates a vector where all values are calculated as (lower_bound + upper_bound)/2. Default is \"random\".\n        max_constants int: The maximum number of constants allowed in the expression. Default is 8.\n        max_expr_length int: The maximum length of the expression. Default is -1 (no limit).\n\n    Methods:\n        estimate_parameters(expr: List[str]): Estimates the parameters of an expression by minimizing the error between the predicted and actual values.\n    \"\"\"\n    self.symbol_library = symbol_library\n    self.X = X\n    self.y = y\n    # self.stats = {\"success\": 0, \"failure\": 0, \"steps\": dict(), \"num_constants\": dict(), \"failed_constants\": dict()}\n\n    self.estimation_settings = {\n            \"method\": \"L-BFGS-B\",\n            \"tol\": 1e-6,\n            \"gtol\": 1e-3,\n            \"max_iter\": 100,\n            \"bounds\": [-5, 5],\n            \"initialization\": \"random\", # random, mean\n            \"max_constants\": 8,\n            \"max_expr_length\": -1\n    }\n\n    if kwargs:\n        self.estimation_settings.update(kwargs)\n</code></pre>"},{"location":"references/evaluation/#SRToolkit.evaluation.ParameterEstimator.estimate_parameters","title":"<code>estimate_parameters(expr)</code>","text":"<p>Estimates the parameters of an expression by minimizing the error between the predicted and actual values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n&gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n&gt;&gt;&gt; pe = ParameterEstimator(X, y)\n&gt;&gt;&gt; rmse, constants = pe.estimate_parameters([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n&gt;&gt;&gt; print(rmse &lt; 1e-6)\nTrue\n&gt;&gt;&gt; print(1.99 &lt; constants[0] &lt; 2.01)\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>List[str]</code> <p>A list of strings representing the expression to be evaluated. The expression should include the   symbol 'C' for constants whose values need to be estimated.</p> required <p>Returns:</p> Type Description <code>float</code> <p>the root mean square error (RMSE) of the optimized expression.</p> <code>ndarray</code> <p>An array containing the optimized constant values.</p> Notes <p>if the length of the expression exceeds the maximum allowed, NaN and an empty array are returned. If the number of constants in the expression exceeds the maximum allowed, NaN and an empty array are returned. If there are no constants in the expression, the RMSE is calculated directly without optimization.</p> Source code in <code>SRToolkit/evaluation/parameter_estimator.py</code> <pre><code>def estimate_parameters(self, expr: List[str]) -&gt; Tuple[float, np.ndarray]:\n    \"\"\"\n    Estimates the parameters of an expression by minimizing the error between the predicted and actual values.\n\n    Examples:\n        &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n        &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n        &gt;&gt;&gt; pe = ParameterEstimator(X, y)\n        &gt;&gt;&gt; rmse, constants = pe.estimate_parameters([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n        &gt;&gt;&gt; print(rmse &lt; 1e-6)\n        True\n        &gt;&gt;&gt; print(1.99 &lt; constants[0] &lt; 2.01)\n        True\n\n    Args:\n        expr: A list of strings representing the expression to be evaluated. The expression should include the\n              symbol 'C' for constants whose values need to be estimated.\n\n    Returns:\n        the root mean square error (RMSE) of the optimized expression.\n        An array containing the optimized constant values.\n\n    Notes:\n        if the length of the expression exceeds the maximum allowed, NaN and an empty array are returned.\n        If the number of constants in the expression exceeds the maximum allowed, NaN and an empty array are returned.\n        If there are no constants in the expression, the RMSE is calculated directly without optimization.\n    \"\"\"\n    num_constants = sum([1 for t in expr if t == \"C\"])\n    if 0 &lt;= self.estimation_settings[\"max_constants\"] &lt; num_constants:\n        return np.nan, np.array([])\n\n    if 0 &lt;= self.estimation_settings[\"max_expr_length\"] &lt; len(expr):\n        return np.nan, np.array([])\n\n    executable_error_fn = expr_to_error_function(expr, self.symbol_library)\n\n    if num_constants == 0:\n        rmse = executable_error_fn(self.X, np.array([]), self.y)\n        return rmse, np.array([])\n    else:\n        return self._optimize_parameters(executable_error_fn, num_constants)\n</code></pre>"},{"location":"references/evaluation/#SRToolkit.evaluation.SR_evaluator","title":"<code>SR_evaluator</code>","text":"Source code in <code>SRToolkit/evaluation/sr_evaluator.py</code> <pre><code>class SR_evaluator:\n    def __init__(\n        self,\n        X: np.ndarray,\n        y: np.ndarray,\n        max_evaluations: int = -1,\n        metadata: Optional[dict] = None,\n        symbol_library: SymbolLibrary = SymbolLibrary.default_symbols(),\n        **kwargs\n    ):\n        \"\"\"\n        Initializes an instance of the SR_evaluator class. This class is used for evaluating symbolic regression approaches.\n\n        Examples:\n            &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n            &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n            &gt;&gt;&gt; se = SR_evaluator(X, y)\n            &gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n            &gt;&gt;&gt; print(rmse &lt; 1e-6)\n            True\n\n\n        Attributes:\n            models: A dictionary containing the results of previously evaluated expressions.\n            max_evaluations: The maximum number of expressions to evaluate.\n            metadata: An optional dictionary containing metadata about this evaluation. This could include information such as the dataset used, the model used, seed, etc.\n            symbol_library: The symbol library to use.\n            total_expressions: The total number of expressions considered.\n            parameter_estimator: An instance of the ParameterEstimator class used for parameter estimation.\n\n        Args:\n            X: The input data to be used in parameter estimation for variables. We assume that X is a 2D array with shape (n_samples, n_features).\n            y: The target values to be used in parameter estimation.\n            max_evaluations: The maximum number of expressions to evaluate. Default is -1, which means no limit.\n            metadata: An optional dictionary containing metadata about this evaluation. This could include information such as the dataset used, the model used, seed, etc.\n            symbol_library: The symbol library to use.\n\n        Keyword Arguments:\n            method str: The method to be used for minimization. Currently, only \"L-BFGS-B\" is supported/tested. Default is \"L-BFGS-B\".\n            tol float: The tolerance for termination. Default is 1e-6.\n            gtol float: The tolerance for the gradient norm. Default is 1e-3.\n            max_iter int: The maximum number of iterations. Default is 100.\n            bounds List[float]: A list of two elements, specifying the lower and upper bounds for the constant values. Default is [-5, 5].\n            initialization str: The method to use for initializing the constant values. Currently, only \"random\" and \"mean\" are supported. \"random\" creates a vector with random values\n                                sampled within the bounds. \"mean\" creates a vector where all values are calculated as (lower_bound + upper_bound)/2. Default is \"random\".\n            max_constants int: The maximum number of constants allowed in the expression. Default is 8.\n            max_expr_length int: The maximum length of the expression. Default is -1 (no limit).\n\n        Methods:\n            evaluate_expr(expr): Evaluates an expression in infix notation and stores the result in memory to prevent re-evaluation.\n            get_results(top_k): Returns the results of the evaluation.\n        \"\"\"\n        self.models = dict()\n        self.metadata = metadata\n        self.symbol_library = symbol_library\n        self.max_evaluations = max_evaluations\n        self.total_expressions = 0\n        self.parameter_estimator = ParameterEstimator(\n            X, y, symbol_library=symbol_library, **kwargs)\n\n    def evaluate_expr(self, expr: List[str]) -&gt; float:\n        \"\"\"\n        Evaluates an expression in infix notation and stores the result in\n        memory to prevent re-evaluation.\n\n        Examples:\n            &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n            &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n            &gt;&gt;&gt; se = SR_evaluator(X, y)\n            &gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n            &gt;&gt;&gt; print(rmse &lt; 1e-6)\n            True\n\n        Args:\n            expr: A list of strings representing the expression in infix notation.\n\n        Returns:\n            The root mean square error of the expression.\n\n        Warnings:\n            Maximum number of evaluations reached: If the maximum number of evaluations has been reached, a warning is printed and np.nan is returned.\n\n        Notes:\n            If the expression has already been evaluated, its stored value is returned instead of re-evaluating the expression.\n            When the maximum number of evaluations has been reached, a warning is printed and np.nan is returned.\n        \"\"\"\n        self.total_expressions += 1\n\n        if 0 &lt;= self.max_evaluations &lt; self.total_expressions:\n            warnings.warn(\n                f\"Maximum number of evaluations ({self.max_evaluations}) reached. Stopping evaluation.\")\n            return np.nan\n        else:\n            expr_str = \"\".join(expr)\n            if expr_str in self.models:\n                # print(f\"Already evaluated {expr_str}\")\n                # print(self.models[expr_str])\n                return self.models[expr_str][\"rmse\"]\n            else:\n                rmse, parameters = self.parameter_estimator.estimate_parameters(expr)\n                self.models[expr_str] = {\n                    \"rmse\": rmse,\n                    \"parameters\": parameters,\n                    \"expr\": expr,\n                }\n                return rmse\n\n    # def evaluate_exprs(\n    #     self, exprs: List[List[str]], num_processes: int = 1\n    # ) -&gt; List[float]:\n    #     if num_processes &gt; 1:\n    #         pool = Pool(num_processes)\n    #         results = pool.map(self.evaluate_expr, exprs)\n    #         pool.close()\n    #         for r in results:\n    #             self.models\n    #         return results\n    #     else:\n    #         return [self.evaluate_expr(expr) for expr in exprs]\n\n    def get_results(self, top_k: int = 20, success_threshold: float = 1e-7) -&gt; dict:\n        \"\"\"\n        Returns the results of the equation discovery/symbolic regression process/evaluation.\n\n        Examples:\n            &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n            &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n            &gt;&gt;&gt; se = SR_evaluator(X, y)\n            &gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n            &gt;&gt;&gt; results = se.get_results(top_k=1)\n            &gt;&gt;&gt; print(results[\"num_evaluated\"])\n            1\n            &gt;&gt;&gt; print(results[\"total_expressions\"])\n            1\n            &gt;&gt;&gt; print(results[\"best_expr\"])\n            C*X_1-X_0\n            &gt;&gt;&gt; print(results[\"min_rmse\"] &lt; 1e-6)\n            True\n            &gt;&gt;&gt; print(1.99 &lt; results[\"results\"][0][\"parameters\"][0] &lt; 2.01)\n            True\n\n        Args:\n            top_k: The number of top results to include in the output. If `top_k`\n                is greater than the number of evaluated expressions, all\n                evaluated expressions are included. If `top_k` is less than 0,\n                all evaluated expressions are included.\n            success_threshold: The threshold below which the evaluation is\n                considered successful. Default is 1e-7.\n\n        Returns:\n            A dictionary containing the results of the equation discovery/symbolic regression process. The keys are:\n\n                - \"metadata\" : The metadata provided in the constructor.\n                - \"min_rmse\" : The minimum root mean squared error.\n                - \"best_expr\" : The expression with the minimum root mean\n                  squared error.\n                - \"num_evaluated\" : The number of evaluated expressions.\n                - \"total_expressions\" : The total number of expressions\n                  considered.\n                - \"success\" : Whether the evaluation was successful.\n                - \"results\" : A list of dictionaries, where each dictionary\n                  contains the root mean squared error, the expression, and the\n                  estimated parameters of the expression. The list is sorted in\n                  ascending order of the root mean squared error.\n        \"\"\"\n        if top_k &gt; len(self.models) or top_k &lt; 0:\n            top_k = len(self.models)\n\n        models = list(self.models.values())\n        best_indices = np.argsort([v[\"rmse\"] for v in models])\n\n        results = {\n            \"metadata\": self.metadata,\n            \"min_rmse\": models[best_indices[0]][\"rmse\"],\n            \"best_expr\": \"\".join(models[best_indices[0]][\"expr\"]),\n            \"num_evaluated\": len(models),\n            \"total_expressions\": self.total_expressions,\n            \"results\": list(),\n        }\n\n        # Determine success based on the predefined success threshold\n        if success_threshold is not None and results[\"min_rmse\"] &lt; success_threshold:\n            results[\"success\"] = True\n        else:\n            results[\"success\"] = False\n\n        for i in best_indices[:top_k]:\n            results[\"results\"].append(models[i])\n\n        return results\n</code></pre>"},{"location":"references/evaluation/#SRToolkit.evaluation.SR_evaluator.__init__","title":"<code>__init__(X, y, max_evaluations=-1, metadata=None, symbol_library=SymbolLibrary.default_symbols(), **kwargs)</code>","text":"<p>Initializes an instance of the SR_evaluator class. This class is used for evaluating symbolic regression approaches.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n&gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n&gt;&gt;&gt; se = SR_evaluator(X, y)\n&gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n&gt;&gt;&gt; print(rmse &lt; 1e-6)\nTrue\n</code></pre> <p>Attributes:</p> Name Type Description <code>models</code> <p>A dictionary containing the results of previously evaluated expressions.</p> <code>max_evaluations</code> <p>The maximum number of expressions to evaluate.</p> <code>metadata</code> <p>An optional dictionary containing metadata about this evaluation. This could include information such as the dataset used, the model used, seed, etc.</p> <code>symbol_library</code> <p>The symbol library to use.</p> <code>total_expressions</code> <p>The total number of expressions considered.</p> <code>parameter_estimator</code> <p>An instance of the ParameterEstimator class used for parameter estimation.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>The input data to be used in parameter estimation for variables. We assume that X is a 2D array with shape (n_samples, n_features).</p> required <code>y</code> <code>ndarray</code> <p>The target values to be used in parameter estimation.</p> required <code>max_evaluations</code> <code>int</code> <p>The maximum number of expressions to evaluate. Default is -1, which means no limit.</p> <code>-1</code> <code>metadata</code> <code>Optional[dict]</code> <p>An optional dictionary containing metadata about this evaluation. This could include information such as the dataset used, the model used, seed, etc.</p> <code>None</code> <code>symbol_library</code> <code>SymbolLibrary</code> <p>The symbol library to use.</p> <code>default_symbols()</code> <p>Other Parameters:</p> Name Type Description <code>method</code> <code>str</code> <p>The method to be used for minimization. Currently, only \"L-BFGS-B\" is supported/tested. Default is \"L-BFGS-B\".</p> <code>tol</code> <code>float</code> <p>The tolerance for termination. Default is 1e-6.</p> <code>gtol</code> <code>float</code> <p>The tolerance for the gradient norm. Default is 1e-3.</p> <code>max_iter</code> <code>int</code> <p>The maximum number of iterations. Default is 100.</p> <code>bounds</code> <code>List[float]</code> <p>A list of two elements, specifying the lower and upper bounds for the constant values. Default is [-5, 5].</p> <code>initialization</code> <code>str</code> <p>The method to use for initializing the constant values. Currently, only \"random\" and \"mean\" are supported. \"random\" creates a vector with random values                 sampled within the bounds. \"mean\" creates a vector where all values are calculated as (lower_bound + upper_bound)/2. Default is \"random\".</p> <code>max_constants</code> <code>int</code> <p>The maximum number of constants allowed in the expression. Default is 8.</p> <code>max_expr_length</code> <code>int</code> <p>The maximum length of the expression. Default is -1 (no limit).</p> <p>Functions:</p> Name Description <code>evaluate_expr</code> <p>Evaluates an expression in infix notation and stores the result in memory to prevent re-evaluation.</p> <code>get_results</code> <p>Returns the results of the evaluation.</p> Source code in <code>SRToolkit/evaluation/sr_evaluator.py</code> <pre><code>def __init__(\n    self,\n    X: np.ndarray,\n    y: np.ndarray,\n    max_evaluations: int = -1,\n    metadata: Optional[dict] = None,\n    symbol_library: SymbolLibrary = SymbolLibrary.default_symbols(),\n    **kwargs\n):\n    \"\"\"\n    Initializes an instance of the SR_evaluator class. This class is used for evaluating symbolic regression approaches.\n\n    Examples:\n        &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n        &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n        &gt;&gt;&gt; se = SR_evaluator(X, y)\n        &gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n        &gt;&gt;&gt; print(rmse &lt; 1e-6)\n        True\n\n\n    Attributes:\n        models: A dictionary containing the results of previously evaluated expressions.\n        max_evaluations: The maximum number of expressions to evaluate.\n        metadata: An optional dictionary containing metadata about this evaluation. This could include information such as the dataset used, the model used, seed, etc.\n        symbol_library: The symbol library to use.\n        total_expressions: The total number of expressions considered.\n        parameter_estimator: An instance of the ParameterEstimator class used for parameter estimation.\n\n    Args:\n        X: The input data to be used in parameter estimation for variables. We assume that X is a 2D array with shape (n_samples, n_features).\n        y: The target values to be used in parameter estimation.\n        max_evaluations: The maximum number of expressions to evaluate. Default is -1, which means no limit.\n        metadata: An optional dictionary containing metadata about this evaluation. This could include information such as the dataset used, the model used, seed, etc.\n        symbol_library: The symbol library to use.\n\n    Keyword Arguments:\n        method str: The method to be used for minimization. Currently, only \"L-BFGS-B\" is supported/tested. Default is \"L-BFGS-B\".\n        tol float: The tolerance for termination. Default is 1e-6.\n        gtol float: The tolerance for the gradient norm. Default is 1e-3.\n        max_iter int: The maximum number of iterations. Default is 100.\n        bounds List[float]: A list of two elements, specifying the lower and upper bounds for the constant values. Default is [-5, 5].\n        initialization str: The method to use for initializing the constant values. Currently, only \"random\" and \"mean\" are supported. \"random\" creates a vector with random values\n                            sampled within the bounds. \"mean\" creates a vector where all values are calculated as (lower_bound + upper_bound)/2. Default is \"random\".\n        max_constants int: The maximum number of constants allowed in the expression. Default is 8.\n        max_expr_length int: The maximum length of the expression. Default is -1 (no limit).\n\n    Methods:\n        evaluate_expr(expr): Evaluates an expression in infix notation and stores the result in memory to prevent re-evaluation.\n        get_results(top_k): Returns the results of the evaluation.\n    \"\"\"\n    self.models = dict()\n    self.metadata = metadata\n    self.symbol_library = symbol_library\n    self.max_evaluations = max_evaluations\n    self.total_expressions = 0\n    self.parameter_estimator = ParameterEstimator(\n        X, y, symbol_library=symbol_library, **kwargs)\n</code></pre>"},{"location":"references/evaluation/#SRToolkit.evaluation.SR_evaluator.evaluate_expr","title":"<code>evaluate_expr(expr)</code>","text":"<p>Evaluates an expression in infix notation and stores the result in memory to prevent re-evaluation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n&gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n&gt;&gt;&gt; se = SR_evaluator(X, y)\n&gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n&gt;&gt;&gt; print(rmse &lt; 1e-6)\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>List[str]</code> <p>A list of strings representing the expression in infix notation.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The root mean square error of the expression.</p> <p>Warns:</p> Type Description <code>Maximum number of evaluations reached</code> <p>If the maximum number of evaluations has been reached, a warning is printed and np.nan is returned.</p> Notes <p>If the expression has already been evaluated, its stored value is returned instead of re-evaluating the expression. When the maximum number of evaluations has been reached, a warning is printed and np.nan is returned.</p> Source code in <code>SRToolkit/evaluation/sr_evaluator.py</code> <pre><code>def evaluate_expr(self, expr: List[str]) -&gt; float:\n    \"\"\"\n    Evaluates an expression in infix notation and stores the result in\n    memory to prevent re-evaluation.\n\n    Examples:\n        &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n        &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n        &gt;&gt;&gt; se = SR_evaluator(X, y)\n        &gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n        &gt;&gt;&gt; print(rmse &lt; 1e-6)\n        True\n\n    Args:\n        expr: A list of strings representing the expression in infix notation.\n\n    Returns:\n        The root mean square error of the expression.\n\n    Warnings:\n        Maximum number of evaluations reached: If the maximum number of evaluations has been reached, a warning is printed and np.nan is returned.\n\n    Notes:\n        If the expression has already been evaluated, its stored value is returned instead of re-evaluating the expression.\n        When the maximum number of evaluations has been reached, a warning is printed and np.nan is returned.\n    \"\"\"\n    self.total_expressions += 1\n\n    if 0 &lt;= self.max_evaluations &lt; self.total_expressions:\n        warnings.warn(\n            f\"Maximum number of evaluations ({self.max_evaluations}) reached. Stopping evaluation.\")\n        return np.nan\n    else:\n        expr_str = \"\".join(expr)\n        if expr_str in self.models:\n            # print(f\"Already evaluated {expr_str}\")\n            # print(self.models[expr_str])\n            return self.models[expr_str][\"rmse\"]\n        else:\n            rmse, parameters = self.parameter_estimator.estimate_parameters(expr)\n            self.models[expr_str] = {\n                \"rmse\": rmse,\n                \"parameters\": parameters,\n                \"expr\": expr,\n            }\n            return rmse\n</code></pre>"},{"location":"references/evaluation/#SRToolkit.evaluation.SR_evaluator.get_results","title":"<code>get_results(top_k=20, success_threshold=1e-07)</code>","text":"<p>Returns the results of the equation discovery/symbolic regression process/evaluation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n&gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n&gt;&gt;&gt; se = SR_evaluator(X, y)\n&gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n&gt;&gt;&gt; results = se.get_results(top_k=1)\n&gt;&gt;&gt; print(results[\"num_evaluated\"])\n1\n&gt;&gt;&gt; print(results[\"total_expressions\"])\n1\n&gt;&gt;&gt; print(results[\"best_expr\"])\nC*X_1-X_0\n&gt;&gt;&gt; print(results[\"min_rmse\"] &lt; 1e-6)\nTrue\n&gt;&gt;&gt; print(1.99 &lt; results[\"results\"][0][\"parameters\"][0] &lt; 2.01)\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>top_k</code> <code>int</code> <p>The number of top results to include in the output. If <code>top_k</code> is greater than the number of evaluated expressions, all evaluated expressions are included. If <code>top_k</code> is less than 0, all evaluated expressions are included.</p> <code>20</code> <code>success_threshold</code> <code>float</code> <p>The threshold below which the evaluation is considered successful. Default is 1e-7.</p> <code>1e-07</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the results of the equation discovery/symbolic regression process. The keys are:</p> <ul> <li>\"metadata\" : The metadata provided in the constructor.</li> <li>\"min_rmse\" : The minimum root mean squared error.</li> <li>\"best_expr\" : The expression with the minimum root mean   squared error.</li> <li>\"num_evaluated\" : The number of evaluated expressions.</li> <li>\"total_expressions\" : The total number of expressions   considered.</li> <li>\"success\" : Whether the evaluation was successful.</li> <li>\"results\" : A list of dictionaries, where each dictionary   contains the root mean squared error, the expression, and the   estimated parameters of the expression. The list is sorted in   ascending order of the root mean squared error.</li> </ul> Source code in <code>SRToolkit/evaluation/sr_evaluator.py</code> <pre><code>def get_results(self, top_k: int = 20, success_threshold: float = 1e-7) -&gt; dict:\n    \"\"\"\n    Returns the results of the equation discovery/symbolic regression process/evaluation.\n\n    Examples:\n        &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n        &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n        &gt;&gt;&gt; se = SR_evaluator(X, y)\n        &gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n        &gt;&gt;&gt; results = se.get_results(top_k=1)\n        &gt;&gt;&gt; print(results[\"num_evaluated\"])\n        1\n        &gt;&gt;&gt; print(results[\"total_expressions\"])\n        1\n        &gt;&gt;&gt; print(results[\"best_expr\"])\n        C*X_1-X_0\n        &gt;&gt;&gt; print(results[\"min_rmse\"] &lt; 1e-6)\n        True\n        &gt;&gt;&gt; print(1.99 &lt; results[\"results\"][0][\"parameters\"][0] &lt; 2.01)\n        True\n\n    Args:\n        top_k: The number of top results to include in the output. If `top_k`\n            is greater than the number of evaluated expressions, all\n            evaluated expressions are included. If `top_k` is less than 0,\n            all evaluated expressions are included.\n        success_threshold: The threshold below which the evaluation is\n            considered successful. Default is 1e-7.\n\n    Returns:\n        A dictionary containing the results of the equation discovery/symbolic regression process. The keys are:\n\n            - \"metadata\" : The metadata provided in the constructor.\n            - \"min_rmse\" : The minimum root mean squared error.\n            - \"best_expr\" : The expression with the minimum root mean\n              squared error.\n            - \"num_evaluated\" : The number of evaluated expressions.\n            - \"total_expressions\" : The total number of expressions\n              considered.\n            - \"success\" : Whether the evaluation was successful.\n            - \"results\" : A list of dictionaries, where each dictionary\n              contains the root mean squared error, the expression, and the\n              estimated parameters of the expression. The list is sorted in\n              ascending order of the root mean squared error.\n    \"\"\"\n    if top_k &gt; len(self.models) or top_k &lt; 0:\n        top_k = len(self.models)\n\n    models = list(self.models.values())\n    best_indices = np.argsort([v[\"rmse\"] for v in models])\n\n    results = {\n        \"metadata\": self.metadata,\n        \"min_rmse\": models[best_indices[0]][\"rmse\"],\n        \"best_expr\": \"\".join(models[best_indices[0]][\"expr\"]),\n        \"num_evaluated\": len(models),\n        \"total_expressions\": self.total_expressions,\n        \"results\": list(),\n    }\n\n    # Determine success based on the predefined success threshold\n    if success_threshold is not None and results[\"min_rmse\"] &lt; success_threshold:\n        results[\"success\"] = True\n    else:\n        results[\"success\"] = False\n\n    for i in best_indices[:top_k]:\n        results[\"results\"].append(models[i])\n\n    return results\n</code></pre>"},{"location":"references/evaluation/parameter_estimator/","title":"Parameter Estimator Module","text":""},{"location":"references/evaluation/parameter_estimator/#SRToolkit.evaluation.parameter_estimator","title":"<code>SRToolkit.evaluation.parameter_estimator</code>","text":"<p>This module contains the ParameterEstimator class, which is used to estimate the parameters of an expression.</p>"},{"location":"references/evaluation/parameter_estimator/#SRToolkit.evaluation.parameter_estimator.ParameterEstimator","title":"<code>ParameterEstimator</code>","text":"Source code in <code>SRToolkit/evaluation/parameter_estimator.py</code> <pre><code>class ParameterEstimator:\n    def __init__(self, X: np.ndarray, y: np.ndarray, symbol_library: SymbolLibrary=SymbolLibrary.default_symbols(), **kwargs):\n        \"\"\"\n        Initializes an instance of the ParameterEstimator class.\n\n        Examples:\n            &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n            &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n            &gt;&gt;&gt; pe = ParameterEstimator(X, y)\n            &gt;&gt;&gt; rmse, constants = pe.estimate_parameters([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n            &gt;&gt;&gt; print(rmse &lt; 1e-6)\n            True\n            &gt;&gt;&gt; print(1.99 &lt; constants[0] &lt; 2.01)\n            True\n\n        Args:\n            X: The input data to be used in parameter estimation for variables. We assume that X is a 2D array\n                with shape (n_samples, n_features).\n            y: The target values to be used in parameter estimation.\n            symbol_library: The symbol library to use. Defaults to SymbolLibrary.default_symbols().\n\n        Keyword Arguments:\n            method str: The method to be used for minimization. Currently, only \"L-BFGS-B\" is supported/tested. Default is \"L-BFGS-B\".\n            tol float: The tolerance for termination. Default is 1e-6.\n            gtol float: The tolerance for the gradient norm. Default is 1e-3.\n            max_iter int: The maximum number of iterations. Default is 100.\n            bounds List[float]: A list of two elements, specifying the lower and upper bounds for the constant values. Default is [-5, 5].\n            initialization str: The method to use for initializing the constant values. Currently, only \"random\" and \"mean\" are supported. \"random\" creates a vector with random values\n                                sampled within the bounds. \"mean\" creates a vector where all values are calculated as (lower_bound + upper_bound)/2. Default is \"random\".\n            max_constants int: The maximum number of constants allowed in the expression. Default is 8.\n            max_expr_length int: The maximum length of the expression. Default is -1 (no limit).\n\n        Methods:\n            estimate_parameters(expr: List[str]): Estimates the parameters of an expression by minimizing the error between the predicted and actual values.\n        \"\"\"\n        self.symbol_library = symbol_library\n        self.X = X\n        self.y = y\n        # self.stats = {\"success\": 0, \"failure\": 0, \"steps\": dict(), \"num_constants\": dict(), \"failed_constants\": dict()}\n\n        self.estimation_settings = {\n                \"method\": \"L-BFGS-B\",\n                \"tol\": 1e-6,\n                \"gtol\": 1e-3,\n                \"max_iter\": 100,\n                \"bounds\": [-5, 5],\n                \"initialization\": \"random\", # random, mean\n                \"max_constants\": 8,\n                \"max_expr_length\": -1\n        }\n\n        if kwargs:\n            self.estimation_settings.update(kwargs)\n\n    def estimate_parameters(self, expr: List[str]) -&gt; Tuple[float, np.ndarray]:\n        \"\"\"\n        Estimates the parameters of an expression by minimizing the error between the predicted and actual values.\n\n        Examples:\n            &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n            &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n            &gt;&gt;&gt; pe = ParameterEstimator(X, y)\n            &gt;&gt;&gt; rmse, constants = pe.estimate_parameters([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n            &gt;&gt;&gt; print(rmse &lt; 1e-6)\n            True\n            &gt;&gt;&gt; print(1.99 &lt; constants[0] &lt; 2.01)\n            True\n\n        Args:\n            expr: A list of strings representing the expression to be evaluated. The expression should include the\n                  symbol 'C' for constants whose values need to be estimated.\n\n        Returns:\n            the root mean square error (RMSE) of the optimized expression.\n            An array containing the optimized constant values.\n\n        Notes:\n            if the length of the expression exceeds the maximum allowed, NaN and an empty array are returned.\n            If the number of constants in the expression exceeds the maximum allowed, NaN and an empty array are returned.\n            If there are no constants in the expression, the RMSE is calculated directly without optimization.\n        \"\"\"\n        num_constants = sum([1 for t in expr if t == \"C\"])\n        if 0 &lt;= self.estimation_settings[\"max_constants\"] &lt; num_constants:\n            return np.nan, np.array([])\n\n        if 0 &lt;= self.estimation_settings[\"max_expr_length\"] &lt; len(expr):\n            return np.nan, np.array([])\n\n        executable_error_fn = expr_to_error_function(expr, self.symbol_library)\n\n        if num_constants == 0:\n            rmse = executable_error_fn(self.X, np.array([]), self.y)\n            return rmse, np.array([])\n        else:\n            return self._optimize_parameters(executable_error_fn, num_constants)\n\n    def _optimize_parameters(self, executable_error_fn: callable, num_constants: int) -&gt; Tuple[float, np.ndarray]:\n        \"\"\"\n        Optimizes the parameters of a given expression by minimizing the root mean squared error between the predicted and actual values.\n\n        Parameters\n        ----------\n        executable_error_fn : callable\n            A function that takes in the input values, the constant values, and the target values and returns the root mean squared error.\n        num_constants : int\n            The number of constants in the expression.\n\n        Returns\n        -------\n        float\n            The root mean square error of the optimized expression.\n        np.ndarray\n            An array containing the optimized constant values.\n        \"\"\"\n        if self.estimation_settings[\"initialization\"] == \"random\":\n            x0 = np.random.rand(num_constants) * (self.estimation_settings[\"bounds\"][1] - self.estimation_settings[\"bounds\"][0]) + self.estimation_settings[\"bounds\"][0]\n        else:\n            x0 = np.array([np.mean(self.estimation_settings[\"bounds\"]) for _ in range(num_constants)])\n\n        res = minimize(lambda c: executable_error_fn(self.X, c, self.y), x0, method=self.estimation_settings[\"method\"],\n                       tol=self.estimation_settings[\"tol\"],\n                       options={\n                           \"maxiter\": self.estimation_settings[\"max_iter\"],\n                           \"gtol\": self.estimation_settings[\"gtol\"]\n                                },\n                       bounds=[(self.estimation_settings[\"bounds\"][0], self.estimation_settings[\"bounds\"][1]) for _ in range(num_constants)])\n\n        # if res.success:\n        #     self.stats[\"success\"] += 1\n        # else:\n        #     self.stats[\"failure\"] += 1\n        #     if num_constants in self.stats[\"failed_constants\"]:\n        #         self.stats[\"failed_constants\"][num_constants] += 1\n        #     else:\n        #         self.stats[\"failed_constants\"][num_constants] = 1\n        #\n        # if res.nit in self.stats[\"steps\"]:\n        #     self.stats[\"steps\"][res.nit] += 1\n        # else:\n        #     self.stats[\"steps\"][res.nit] = 1\n        #\n        # if num_constants in self.stats[\"num_constants\"]:\n        #     self.stats[\"num_constants\"][num_constants] += 1\n        # else:\n        #     self.stats[\"num_constants\"][num_constants] = 1\n\n        return res.fun, res.x\n</code></pre>"},{"location":"references/evaluation/parameter_estimator/#SRToolkit.evaluation.parameter_estimator.ParameterEstimator.__init__","title":"<code>__init__(X, y, symbol_library=SymbolLibrary.default_symbols(), **kwargs)</code>","text":"<p>Initializes an instance of the ParameterEstimator class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n&gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n&gt;&gt;&gt; pe = ParameterEstimator(X, y)\n&gt;&gt;&gt; rmse, constants = pe.estimate_parameters([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n&gt;&gt;&gt; print(rmse &lt; 1e-6)\nTrue\n&gt;&gt;&gt; print(1.99 &lt; constants[0] &lt; 2.01)\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>The input data to be used in parameter estimation for variables. We assume that X is a 2D array with shape (n_samples, n_features).</p> required <code>y</code> <code>ndarray</code> <p>The target values to be used in parameter estimation.</p> required <code>symbol_library</code> <code>SymbolLibrary</code> <p>The symbol library to use. Defaults to SymbolLibrary.default_symbols().</p> <code>default_symbols()</code> <p>Other Parameters:</p> Name Type Description <code>method</code> <code>str</code> <p>The method to be used for minimization. Currently, only \"L-BFGS-B\" is supported/tested. Default is \"L-BFGS-B\".</p> <code>tol</code> <code>float</code> <p>The tolerance for termination. Default is 1e-6.</p> <code>gtol</code> <code>float</code> <p>The tolerance for the gradient norm. Default is 1e-3.</p> <code>max_iter</code> <code>int</code> <p>The maximum number of iterations. Default is 100.</p> <code>bounds</code> <code>List[float]</code> <p>A list of two elements, specifying the lower and upper bounds for the constant values. Default is [-5, 5].</p> <code>initialization</code> <code>str</code> <p>The method to use for initializing the constant values. Currently, only \"random\" and \"mean\" are supported. \"random\" creates a vector with random values                 sampled within the bounds. \"mean\" creates a vector where all values are calculated as (lower_bound + upper_bound)/2. Default is \"random\".</p> <code>max_constants</code> <code>int</code> <p>The maximum number of constants allowed in the expression. Default is 8.</p> <code>max_expr_length</code> <code>int</code> <p>The maximum length of the expression. Default is -1 (no limit).</p> <p>Functions:</p> Name Description <code>estimate_parameters</code> <p>List[str]): Estimates the parameters of an expression by minimizing the error between the predicted and actual values.</p> Source code in <code>SRToolkit/evaluation/parameter_estimator.py</code> <pre><code>def __init__(self, X: np.ndarray, y: np.ndarray, symbol_library: SymbolLibrary=SymbolLibrary.default_symbols(), **kwargs):\n    \"\"\"\n    Initializes an instance of the ParameterEstimator class.\n\n    Examples:\n        &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n        &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n        &gt;&gt;&gt; pe = ParameterEstimator(X, y)\n        &gt;&gt;&gt; rmse, constants = pe.estimate_parameters([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n        &gt;&gt;&gt; print(rmse &lt; 1e-6)\n        True\n        &gt;&gt;&gt; print(1.99 &lt; constants[0] &lt; 2.01)\n        True\n\n    Args:\n        X: The input data to be used in parameter estimation for variables. We assume that X is a 2D array\n            with shape (n_samples, n_features).\n        y: The target values to be used in parameter estimation.\n        symbol_library: The symbol library to use. Defaults to SymbolLibrary.default_symbols().\n\n    Keyword Arguments:\n        method str: The method to be used for minimization. Currently, only \"L-BFGS-B\" is supported/tested. Default is \"L-BFGS-B\".\n        tol float: The tolerance for termination. Default is 1e-6.\n        gtol float: The tolerance for the gradient norm. Default is 1e-3.\n        max_iter int: The maximum number of iterations. Default is 100.\n        bounds List[float]: A list of two elements, specifying the lower and upper bounds for the constant values. Default is [-5, 5].\n        initialization str: The method to use for initializing the constant values. Currently, only \"random\" and \"mean\" are supported. \"random\" creates a vector with random values\n                            sampled within the bounds. \"mean\" creates a vector where all values are calculated as (lower_bound + upper_bound)/2. Default is \"random\".\n        max_constants int: The maximum number of constants allowed in the expression. Default is 8.\n        max_expr_length int: The maximum length of the expression. Default is -1 (no limit).\n\n    Methods:\n        estimate_parameters(expr: List[str]): Estimates the parameters of an expression by minimizing the error between the predicted and actual values.\n    \"\"\"\n    self.symbol_library = symbol_library\n    self.X = X\n    self.y = y\n    # self.stats = {\"success\": 0, \"failure\": 0, \"steps\": dict(), \"num_constants\": dict(), \"failed_constants\": dict()}\n\n    self.estimation_settings = {\n            \"method\": \"L-BFGS-B\",\n            \"tol\": 1e-6,\n            \"gtol\": 1e-3,\n            \"max_iter\": 100,\n            \"bounds\": [-5, 5],\n            \"initialization\": \"random\", # random, mean\n            \"max_constants\": 8,\n            \"max_expr_length\": -1\n    }\n\n    if kwargs:\n        self.estimation_settings.update(kwargs)\n</code></pre>"},{"location":"references/evaluation/parameter_estimator/#SRToolkit.evaluation.parameter_estimator.ParameterEstimator.estimate_parameters","title":"<code>estimate_parameters(expr)</code>","text":"<p>Estimates the parameters of an expression by minimizing the error between the predicted and actual values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n&gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n&gt;&gt;&gt; pe = ParameterEstimator(X, y)\n&gt;&gt;&gt; rmse, constants = pe.estimate_parameters([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n&gt;&gt;&gt; print(rmse &lt; 1e-6)\nTrue\n&gt;&gt;&gt; print(1.99 &lt; constants[0] &lt; 2.01)\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>List[str]</code> <p>A list of strings representing the expression to be evaluated. The expression should include the   symbol 'C' for constants whose values need to be estimated.</p> required <p>Returns:</p> Type Description <code>float</code> <p>the root mean square error (RMSE) of the optimized expression.</p> <code>ndarray</code> <p>An array containing the optimized constant values.</p> Notes <p>if the length of the expression exceeds the maximum allowed, NaN and an empty array are returned. If the number of constants in the expression exceeds the maximum allowed, NaN and an empty array are returned. If there are no constants in the expression, the RMSE is calculated directly without optimization.</p> Source code in <code>SRToolkit/evaluation/parameter_estimator.py</code> <pre><code>def estimate_parameters(self, expr: List[str]) -&gt; Tuple[float, np.ndarray]:\n    \"\"\"\n    Estimates the parameters of an expression by minimizing the error between the predicted and actual values.\n\n    Examples:\n        &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n        &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n        &gt;&gt;&gt; pe = ParameterEstimator(X, y)\n        &gt;&gt;&gt; rmse, constants = pe.estimate_parameters([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n        &gt;&gt;&gt; print(rmse &lt; 1e-6)\n        True\n        &gt;&gt;&gt; print(1.99 &lt; constants[0] &lt; 2.01)\n        True\n\n    Args:\n        expr: A list of strings representing the expression to be evaluated. The expression should include the\n              symbol 'C' for constants whose values need to be estimated.\n\n    Returns:\n        the root mean square error (RMSE) of the optimized expression.\n        An array containing the optimized constant values.\n\n    Notes:\n        if the length of the expression exceeds the maximum allowed, NaN and an empty array are returned.\n        If the number of constants in the expression exceeds the maximum allowed, NaN and an empty array are returned.\n        If there are no constants in the expression, the RMSE is calculated directly without optimization.\n    \"\"\"\n    num_constants = sum([1 for t in expr if t == \"C\"])\n    if 0 &lt;= self.estimation_settings[\"max_constants\"] &lt; num_constants:\n        return np.nan, np.array([])\n\n    if 0 &lt;= self.estimation_settings[\"max_expr_length\"] &lt; len(expr):\n        return np.nan, np.array([])\n\n    executable_error_fn = expr_to_error_function(expr, self.symbol_library)\n\n    if num_constants == 0:\n        rmse = executable_error_fn(self.X, np.array([]), self.y)\n        return rmse, np.array([])\n    else:\n        return self._optimize_parameters(executable_error_fn, num_constants)\n</code></pre>"},{"location":"references/evaluation/sr_evaluator/","title":"SR Evaluator Module","text":""},{"location":"references/evaluation/sr_evaluator/#SRToolkit.evaluation.sr_evaluator","title":"<code>SRToolkit.evaluation.sr_evaluator</code>","text":"<p>This module contains the SR_evaluator class, which is used for evaluating symbolic regression approaches.</p>"},{"location":"references/evaluation/sr_evaluator/#SRToolkit.evaluation.sr_evaluator.SR_evaluator","title":"<code>SR_evaluator</code>","text":"Source code in <code>SRToolkit/evaluation/sr_evaluator.py</code> <pre><code>class SR_evaluator:\n    def __init__(\n        self,\n        X: np.ndarray,\n        y: np.ndarray,\n        max_evaluations: int = -1,\n        metadata: Optional[dict] = None,\n        symbol_library: SymbolLibrary = SymbolLibrary.default_symbols(),\n        **kwargs\n    ):\n        \"\"\"\n        Initializes an instance of the SR_evaluator class. This class is used for evaluating symbolic regression approaches.\n\n        Examples:\n            &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n            &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n            &gt;&gt;&gt; se = SR_evaluator(X, y)\n            &gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n            &gt;&gt;&gt; print(rmse &lt; 1e-6)\n            True\n\n\n        Attributes:\n            models: A dictionary containing the results of previously evaluated expressions.\n            max_evaluations: The maximum number of expressions to evaluate.\n            metadata: An optional dictionary containing metadata about this evaluation. This could include information such as the dataset used, the model used, seed, etc.\n            symbol_library: The symbol library to use.\n            total_expressions: The total number of expressions considered.\n            parameter_estimator: An instance of the ParameterEstimator class used for parameter estimation.\n\n        Args:\n            X: The input data to be used in parameter estimation for variables. We assume that X is a 2D array with shape (n_samples, n_features).\n            y: The target values to be used in parameter estimation.\n            max_evaluations: The maximum number of expressions to evaluate. Default is -1, which means no limit.\n            metadata: An optional dictionary containing metadata about this evaluation. This could include information such as the dataset used, the model used, seed, etc.\n            symbol_library: The symbol library to use.\n\n        Keyword Arguments:\n            method str: The method to be used for minimization. Currently, only \"L-BFGS-B\" is supported/tested. Default is \"L-BFGS-B\".\n            tol float: The tolerance for termination. Default is 1e-6.\n            gtol float: The tolerance for the gradient norm. Default is 1e-3.\n            max_iter int: The maximum number of iterations. Default is 100.\n            bounds List[float]: A list of two elements, specifying the lower and upper bounds for the constant values. Default is [-5, 5].\n            initialization str: The method to use for initializing the constant values. Currently, only \"random\" and \"mean\" are supported. \"random\" creates a vector with random values\n                                sampled within the bounds. \"mean\" creates a vector where all values are calculated as (lower_bound + upper_bound)/2. Default is \"random\".\n            max_constants int: The maximum number of constants allowed in the expression. Default is 8.\n            max_expr_length int: The maximum length of the expression. Default is -1 (no limit).\n\n        Methods:\n            evaluate_expr(expr): Evaluates an expression in infix notation and stores the result in memory to prevent re-evaluation.\n            get_results(top_k): Returns the results of the evaluation.\n        \"\"\"\n        self.models = dict()\n        self.metadata = metadata\n        self.symbol_library = symbol_library\n        self.max_evaluations = max_evaluations\n        self.total_expressions = 0\n        self.parameter_estimator = ParameterEstimator(\n            X, y, symbol_library=symbol_library, **kwargs)\n\n    def evaluate_expr(self, expr: List[str]) -&gt; float:\n        \"\"\"\n        Evaluates an expression in infix notation and stores the result in\n        memory to prevent re-evaluation.\n\n        Examples:\n            &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n            &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n            &gt;&gt;&gt; se = SR_evaluator(X, y)\n            &gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n            &gt;&gt;&gt; print(rmse &lt; 1e-6)\n            True\n\n        Args:\n            expr: A list of strings representing the expression in infix notation.\n\n        Returns:\n            The root mean square error of the expression.\n\n        Warnings:\n            Maximum number of evaluations reached: If the maximum number of evaluations has been reached, a warning is printed and np.nan is returned.\n\n        Notes:\n            If the expression has already been evaluated, its stored value is returned instead of re-evaluating the expression.\n            When the maximum number of evaluations has been reached, a warning is printed and np.nan is returned.\n        \"\"\"\n        self.total_expressions += 1\n\n        if 0 &lt;= self.max_evaluations &lt; self.total_expressions:\n            warnings.warn(\n                f\"Maximum number of evaluations ({self.max_evaluations}) reached. Stopping evaluation.\")\n            return np.nan\n        else:\n            expr_str = \"\".join(expr)\n            if expr_str in self.models:\n                # print(f\"Already evaluated {expr_str}\")\n                # print(self.models[expr_str])\n                return self.models[expr_str][\"rmse\"]\n            else:\n                rmse, parameters = self.parameter_estimator.estimate_parameters(expr)\n                self.models[expr_str] = {\n                    \"rmse\": rmse,\n                    \"parameters\": parameters,\n                    \"expr\": expr,\n                }\n                return rmse\n\n    # def evaluate_exprs(\n    #     self, exprs: List[List[str]], num_processes: int = 1\n    # ) -&gt; List[float]:\n    #     if num_processes &gt; 1:\n    #         pool = Pool(num_processes)\n    #         results = pool.map(self.evaluate_expr, exprs)\n    #         pool.close()\n    #         for r in results:\n    #             self.models\n    #         return results\n    #     else:\n    #         return [self.evaluate_expr(expr) for expr in exprs]\n\n    def get_results(self, top_k: int = 20, success_threshold: float = 1e-7) -&gt; dict:\n        \"\"\"\n        Returns the results of the equation discovery/symbolic regression process/evaluation.\n\n        Examples:\n            &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n            &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n            &gt;&gt;&gt; se = SR_evaluator(X, y)\n            &gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n            &gt;&gt;&gt; results = se.get_results(top_k=1)\n            &gt;&gt;&gt; print(results[\"num_evaluated\"])\n            1\n            &gt;&gt;&gt; print(results[\"total_expressions\"])\n            1\n            &gt;&gt;&gt; print(results[\"best_expr\"])\n            C*X_1-X_0\n            &gt;&gt;&gt; print(results[\"min_rmse\"] &lt; 1e-6)\n            True\n            &gt;&gt;&gt; print(1.99 &lt; results[\"results\"][0][\"parameters\"][0] &lt; 2.01)\n            True\n\n        Args:\n            top_k: The number of top results to include in the output. If `top_k`\n                is greater than the number of evaluated expressions, all\n                evaluated expressions are included. If `top_k` is less than 0,\n                all evaluated expressions are included.\n            success_threshold: The threshold below which the evaluation is\n                considered successful. Default is 1e-7.\n\n        Returns:\n            A dictionary containing the results of the equation discovery/symbolic regression process. The keys are:\n\n                - \"metadata\" : The metadata provided in the constructor.\n                - \"min_rmse\" : The minimum root mean squared error.\n                - \"best_expr\" : The expression with the minimum root mean\n                  squared error.\n                - \"num_evaluated\" : The number of evaluated expressions.\n                - \"total_expressions\" : The total number of expressions\n                  considered.\n                - \"success\" : Whether the evaluation was successful.\n                - \"results\" : A list of dictionaries, where each dictionary\n                  contains the root mean squared error, the expression, and the\n                  estimated parameters of the expression. The list is sorted in\n                  ascending order of the root mean squared error.\n        \"\"\"\n        if top_k &gt; len(self.models) or top_k &lt; 0:\n            top_k = len(self.models)\n\n        models = list(self.models.values())\n        best_indices = np.argsort([v[\"rmse\"] for v in models])\n\n        results = {\n            \"metadata\": self.metadata,\n            \"min_rmse\": models[best_indices[0]][\"rmse\"],\n            \"best_expr\": \"\".join(models[best_indices[0]][\"expr\"]),\n            \"num_evaluated\": len(models),\n            \"total_expressions\": self.total_expressions,\n            \"results\": list(),\n        }\n\n        # Determine success based on the predefined success threshold\n        if success_threshold is not None and results[\"min_rmse\"] &lt; success_threshold:\n            results[\"success\"] = True\n        else:\n            results[\"success\"] = False\n\n        for i in best_indices[:top_k]:\n            results[\"results\"].append(models[i])\n\n        return results\n</code></pre>"},{"location":"references/evaluation/sr_evaluator/#SRToolkit.evaluation.sr_evaluator.SR_evaluator.__init__","title":"<code>__init__(X, y, max_evaluations=-1, metadata=None, symbol_library=SymbolLibrary.default_symbols(), **kwargs)</code>","text":"<p>Initializes an instance of the SR_evaluator class. This class is used for evaluating symbolic regression approaches.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n&gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n&gt;&gt;&gt; se = SR_evaluator(X, y)\n&gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n&gt;&gt;&gt; print(rmse &lt; 1e-6)\nTrue\n</code></pre> <p>Attributes:</p> Name Type Description <code>models</code> <p>A dictionary containing the results of previously evaluated expressions.</p> <code>max_evaluations</code> <p>The maximum number of expressions to evaluate.</p> <code>metadata</code> <p>An optional dictionary containing metadata about this evaluation. This could include information such as the dataset used, the model used, seed, etc.</p> <code>symbol_library</code> <p>The symbol library to use.</p> <code>total_expressions</code> <p>The total number of expressions considered.</p> <code>parameter_estimator</code> <p>An instance of the ParameterEstimator class used for parameter estimation.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>The input data to be used in parameter estimation for variables. We assume that X is a 2D array with shape (n_samples, n_features).</p> required <code>y</code> <code>ndarray</code> <p>The target values to be used in parameter estimation.</p> required <code>max_evaluations</code> <code>int</code> <p>The maximum number of expressions to evaluate. Default is -1, which means no limit.</p> <code>-1</code> <code>metadata</code> <code>Optional[dict]</code> <p>An optional dictionary containing metadata about this evaluation. This could include information such as the dataset used, the model used, seed, etc.</p> <code>None</code> <code>symbol_library</code> <code>SymbolLibrary</code> <p>The symbol library to use.</p> <code>default_symbols()</code> <p>Other Parameters:</p> Name Type Description <code>method</code> <code>str</code> <p>The method to be used for minimization. Currently, only \"L-BFGS-B\" is supported/tested. Default is \"L-BFGS-B\".</p> <code>tol</code> <code>float</code> <p>The tolerance for termination. Default is 1e-6.</p> <code>gtol</code> <code>float</code> <p>The tolerance for the gradient norm. Default is 1e-3.</p> <code>max_iter</code> <code>int</code> <p>The maximum number of iterations. Default is 100.</p> <code>bounds</code> <code>List[float]</code> <p>A list of two elements, specifying the lower and upper bounds for the constant values. Default is [-5, 5].</p> <code>initialization</code> <code>str</code> <p>The method to use for initializing the constant values. Currently, only \"random\" and \"mean\" are supported. \"random\" creates a vector with random values                 sampled within the bounds. \"mean\" creates a vector where all values are calculated as (lower_bound + upper_bound)/2. Default is \"random\".</p> <code>max_constants</code> <code>int</code> <p>The maximum number of constants allowed in the expression. Default is 8.</p> <code>max_expr_length</code> <code>int</code> <p>The maximum length of the expression. Default is -1 (no limit).</p> <p>Functions:</p> Name Description <code>evaluate_expr</code> <p>Evaluates an expression in infix notation and stores the result in memory to prevent re-evaluation.</p> <code>get_results</code> <p>Returns the results of the evaluation.</p> Source code in <code>SRToolkit/evaluation/sr_evaluator.py</code> <pre><code>def __init__(\n    self,\n    X: np.ndarray,\n    y: np.ndarray,\n    max_evaluations: int = -1,\n    metadata: Optional[dict] = None,\n    symbol_library: SymbolLibrary = SymbolLibrary.default_symbols(),\n    **kwargs\n):\n    \"\"\"\n    Initializes an instance of the SR_evaluator class. This class is used for evaluating symbolic regression approaches.\n\n    Examples:\n        &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n        &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n        &gt;&gt;&gt; se = SR_evaluator(X, y)\n        &gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n        &gt;&gt;&gt; print(rmse &lt; 1e-6)\n        True\n\n\n    Attributes:\n        models: A dictionary containing the results of previously evaluated expressions.\n        max_evaluations: The maximum number of expressions to evaluate.\n        metadata: An optional dictionary containing metadata about this evaluation. This could include information such as the dataset used, the model used, seed, etc.\n        symbol_library: The symbol library to use.\n        total_expressions: The total number of expressions considered.\n        parameter_estimator: An instance of the ParameterEstimator class used for parameter estimation.\n\n    Args:\n        X: The input data to be used in parameter estimation for variables. We assume that X is a 2D array with shape (n_samples, n_features).\n        y: The target values to be used in parameter estimation.\n        max_evaluations: The maximum number of expressions to evaluate. Default is -1, which means no limit.\n        metadata: An optional dictionary containing metadata about this evaluation. This could include information such as the dataset used, the model used, seed, etc.\n        symbol_library: The symbol library to use.\n\n    Keyword Arguments:\n        method str: The method to be used for minimization. Currently, only \"L-BFGS-B\" is supported/tested. Default is \"L-BFGS-B\".\n        tol float: The tolerance for termination. Default is 1e-6.\n        gtol float: The tolerance for the gradient norm. Default is 1e-3.\n        max_iter int: The maximum number of iterations. Default is 100.\n        bounds List[float]: A list of two elements, specifying the lower and upper bounds for the constant values. Default is [-5, 5].\n        initialization str: The method to use for initializing the constant values. Currently, only \"random\" and \"mean\" are supported. \"random\" creates a vector with random values\n                            sampled within the bounds. \"mean\" creates a vector where all values are calculated as (lower_bound + upper_bound)/2. Default is \"random\".\n        max_constants int: The maximum number of constants allowed in the expression. Default is 8.\n        max_expr_length int: The maximum length of the expression. Default is -1 (no limit).\n\n    Methods:\n        evaluate_expr(expr): Evaluates an expression in infix notation and stores the result in memory to prevent re-evaluation.\n        get_results(top_k): Returns the results of the evaluation.\n    \"\"\"\n    self.models = dict()\n    self.metadata = metadata\n    self.symbol_library = symbol_library\n    self.max_evaluations = max_evaluations\n    self.total_expressions = 0\n    self.parameter_estimator = ParameterEstimator(\n        X, y, symbol_library=symbol_library, **kwargs)\n</code></pre>"},{"location":"references/evaluation/sr_evaluator/#SRToolkit.evaluation.sr_evaluator.SR_evaluator.evaluate_expr","title":"<code>evaluate_expr(expr)</code>","text":"<p>Evaluates an expression in infix notation and stores the result in memory to prevent re-evaluation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n&gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n&gt;&gt;&gt; se = SR_evaluator(X, y)\n&gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n&gt;&gt;&gt; print(rmse &lt; 1e-6)\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>List[str]</code> <p>A list of strings representing the expression in infix notation.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The root mean square error of the expression.</p> <p>Warns:</p> Type Description <code>Maximum number of evaluations reached</code> <p>If the maximum number of evaluations has been reached, a warning is printed and np.nan is returned.</p> Notes <p>If the expression has already been evaluated, its stored value is returned instead of re-evaluating the expression. When the maximum number of evaluations has been reached, a warning is printed and np.nan is returned.</p> Source code in <code>SRToolkit/evaluation/sr_evaluator.py</code> <pre><code>def evaluate_expr(self, expr: List[str]) -&gt; float:\n    \"\"\"\n    Evaluates an expression in infix notation and stores the result in\n    memory to prevent re-evaluation.\n\n    Examples:\n        &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n        &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n        &gt;&gt;&gt; se = SR_evaluator(X, y)\n        &gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n        &gt;&gt;&gt; print(rmse &lt; 1e-6)\n        True\n\n    Args:\n        expr: A list of strings representing the expression in infix notation.\n\n    Returns:\n        The root mean square error of the expression.\n\n    Warnings:\n        Maximum number of evaluations reached: If the maximum number of evaluations has been reached, a warning is printed and np.nan is returned.\n\n    Notes:\n        If the expression has already been evaluated, its stored value is returned instead of re-evaluating the expression.\n        When the maximum number of evaluations has been reached, a warning is printed and np.nan is returned.\n    \"\"\"\n    self.total_expressions += 1\n\n    if 0 &lt;= self.max_evaluations &lt; self.total_expressions:\n        warnings.warn(\n            f\"Maximum number of evaluations ({self.max_evaluations}) reached. Stopping evaluation.\")\n        return np.nan\n    else:\n        expr_str = \"\".join(expr)\n        if expr_str in self.models:\n            # print(f\"Already evaluated {expr_str}\")\n            # print(self.models[expr_str])\n            return self.models[expr_str][\"rmse\"]\n        else:\n            rmse, parameters = self.parameter_estimator.estimate_parameters(expr)\n            self.models[expr_str] = {\n                \"rmse\": rmse,\n                \"parameters\": parameters,\n                \"expr\": expr,\n            }\n            return rmse\n</code></pre>"},{"location":"references/evaluation/sr_evaluator/#SRToolkit.evaluation.sr_evaluator.SR_evaluator.get_results","title":"<code>get_results(top_k=20, success_threshold=1e-07)</code>","text":"<p>Returns the results of the equation discovery/symbolic regression process/evaluation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n&gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n&gt;&gt;&gt; se = SR_evaluator(X, y)\n&gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n&gt;&gt;&gt; results = se.get_results(top_k=1)\n&gt;&gt;&gt; print(results[\"num_evaluated\"])\n1\n&gt;&gt;&gt; print(results[\"total_expressions\"])\n1\n&gt;&gt;&gt; print(results[\"best_expr\"])\nC*X_1-X_0\n&gt;&gt;&gt; print(results[\"min_rmse\"] &lt; 1e-6)\nTrue\n&gt;&gt;&gt; print(1.99 &lt; results[\"results\"][0][\"parameters\"][0] &lt; 2.01)\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>top_k</code> <code>int</code> <p>The number of top results to include in the output. If <code>top_k</code> is greater than the number of evaluated expressions, all evaluated expressions are included. If <code>top_k</code> is less than 0, all evaluated expressions are included.</p> <code>20</code> <code>success_threshold</code> <code>float</code> <p>The threshold below which the evaluation is considered successful. Default is 1e-7.</p> <code>1e-07</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the results of the equation discovery/symbolic regression process. The keys are:</p> <ul> <li>\"metadata\" : The metadata provided in the constructor.</li> <li>\"min_rmse\" : The minimum root mean squared error.</li> <li>\"best_expr\" : The expression with the minimum root mean   squared error.</li> <li>\"num_evaluated\" : The number of evaluated expressions.</li> <li>\"total_expressions\" : The total number of expressions   considered.</li> <li>\"success\" : Whether the evaluation was successful.</li> <li>\"results\" : A list of dictionaries, where each dictionary   contains the root mean squared error, the expression, and the   estimated parameters of the expression. The list is sorted in   ascending order of the root mean squared error.</li> </ul> Source code in <code>SRToolkit/evaluation/sr_evaluator.py</code> <pre><code>def get_results(self, top_k: int = 20, success_threshold: float = 1e-7) -&gt; dict:\n    \"\"\"\n    Returns the results of the equation discovery/symbolic regression process/evaluation.\n\n    Examples:\n        &gt;&gt;&gt; X = np.array([[1, 2], [8, 4], [5, 4], [7, 9], ])\n        &gt;&gt;&gt; y = np.array([3, 0, 3, 11])\n        &gt;&gt;&gt; se = SR_evaluator(X, y)\n        &gt;&gt;&gt; rmse = se.evaluate_expr([\"C\", \"*\", \"X_1\", \"-\", \"X_0\"])\n        &gt;&gt;&gt; results = se.get_results(top_k=1)\n        &gt;&gt;&gt; print(results[\"num_evaluated\"])\n        1\n        &gt;&gt;&gt; print(results[\"total_expressions\"])\n        1\n        &gt;&gt;&gt; print(results[\"best_expr\"])\n        C*X_1-X_0\n        &gt;&gt;&gt; print(results[\"min_rmse\"] &lt; 1e-6)\n        True\n        &gt;&gt;&gt; print(1.99 &lt; results[\"results\"][0][\"parameters\"][0] &lt; 2.01)\n        True\n\n    Args:\n        top_k: The number of top results to include in the output. If `top_k`\n            is greater than the number of evaluated expressions, all\n            evaluated expressions are included. If `top_k` is less than 0,\n            all evaluated expressions are included.\n        success_threshold: The threshold below which the evaluation is\n            considered successful. Default is 1e-7.\n\n    Returns:\n        A dictionary containing the results of the equation discovery/symbolic regression process. The keys are:\n\n            - \"metadata\" : The metadata provided in the constructor.\n            - \"min_rmse\" : The minimum root mean squared error.\n            - \"best_expr\" : The expression with the minimum root mean\n              squared error.\n            - \"num_evaluated\" : The number of evaluated expressions.\n            - \"total_expressions\" : The total number of expressions\n              considered.\n            - \"success\" : Whether the evaluation was successful.\n            - \"results\" : A list of dictionaries, where each dictionary\n              contains the root mean squared error, the expression, and the\n              estimated parameters of the expression. The list is sorted in\n              ascending order of the root mean squared error.\n    \"\"\"\n    if top_k &gt; len(self.models) or top_k &lt; 0:\n        top_k = len(self.models)\n\n    models = list(self.models.values())\n    best_indices = np.argsort([v[\"rmse\"] for v in models])\n\n    results = {\n        \"metadata\": self.metadata,\n        \"min_rmse\": models[best_indices[0]][\"rmse\"],\n        \"best_expr\": \"\".join(models[best_indices[0]][\"expr\"]),\n        \"num_evaluated\": len(models),\n        \"total_expressions\": self.total_expressions,\n        \"results\": list(),\n    }\n\n    # Determine success based on the predefined success threshold\n    if success_threshold is not None and results[\"min_rmse\"] &lt; success_threshold:\n        results[\"success\"] = True\n    else:\n        results[\"success\"] = False\n\n    for i in best_indices[:top_k]:\n        results[\"results\"].append(models[i])\n\n    return results\n</code></pre>"},{"location":"references/utils/","title":"Utils Module","text":""},{"location":"references/utils/#SRToolkit.utils","title":"<code>SRToolkit.utils</code>","text":"<p>The module containing the <code>utils</code>.</p> <p>The <code>utils</code> module provides a set of utilities used in the package and for expression compilation.</p> <p>Modules:</p> Name Description <code>symbol_library</code> <p>The module containing the symbol library data structure for managing symbols that can occur in expressions and their properties.</p> <code>expression_tree</code> <p>The module containing the expression tree data structure and functions for transforming expressions into trees and back.</p> <code>expression_compiler</code> <p>The module containing functions that transform expressions in the infix notation (represented as lists of tokens) to executable python functions.</p>"},{"location":"references/utils/#SRToolkit.utils.Node","title":"<code>Node</code>","text":"Source code in <code>SRToolkit/utils/expression_tree.py</code> <pre><code>class Node:\n    def __init__(self, symbol: str = None, right: \"Node\" = None, left: \"Node\" = None):\n        \"\"\"\n        Initializes a Node object. We assume that nodes containing functions have only one child node, i.e. right is None.\n\n        Examples:\n            &gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n            &gt;&gt;&gt; len(node)\n            3\n\n        Args:\n            symbol: The symbol string stored in this node.\n            right: The right child of this node.\n            left: The left child of this node.\n\n        Methods:\n            __len__(self):\n                Returns the number of nodes in the tree rooted at this node.\n            __str__(self):\n                Returns a string representation of the tree rooted at this node.\n            to_list(self, notation: str = \"infix\", symbol_library: SymbolLibrary = None):\n                Returns a list representation of the tree rooted at this node.\n\n        \"\"\"\n        self.symbol = symbol\n        self.right = right\n        self.left = left\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of nodes in the tree rooted at this node.\n\n        Examples:\n            &gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n            &gt;&gt;&gt; len(node)\n            3\n\n        Returns:\n            The number of nodes in the tree rooted at this node.\n        \"\"\"\n        return (\n            1\n            + (len(self.left) if self.left is not None else 0)\n            + (len(self.right) if self.right is not None else 0)\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a string representation of the tree rooted at this node.\n\n        Examples:\n            &gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n            &gt;&gt;&gt; str(node)\n            'x+1'\n\n        Returns:\n            A string representation of the tree rooted at this node.\n        \"\"\"\n        return \"\".join(self.to_list())\n\n    def to_list(self, notation: str = \"infix\", symbol_library: SymbolLibrary = None) -&gt; List[str]:\n        \"\"\"\n        Transforms the tree rooted at this node into a list of tokens.\n\n        Examples:\n            &gt;&gt;&gt; node = Node(\"+\", Node(\"X_0\"), Node(\"1\"))\n            &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n            ['1', '+', 'X_0']\n            &gt;&gt;&gt; node.to_list(notation=\"postfix\")\n            ['1', 'X_0', '+']\n            &gt;&gt;&gt; node.to_list(notation=\"prefix\")\n            ['+', '1', 'X_0']\n            &gt;&gt;&gt; node = Node(\"+\", Node(\"*\", Node(\"X_0\"), Node(\"X_1\")), Node(\"1\"))\n            &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n            ['1', '+', 'X_1', '*', 'X_0']\n            &gt;&gt;&gt; node.to_list(notation=\"infix\")\n            ['1', '+', '(', 'X_1', '*', 'X_0', ')']\n            &gt;&gt;&gt; node = Node(\"sin\", None, Node(\"X_0\"))\n            &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n            ['sin', '(', 'X_0', ')']\n            &gt;&gt;&gt; node = Node(\"^2\", None, Node(\"X_0\"))\n            &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n            ['X_0', '^2']\n            &gt;&gt;&gt; node.to_list()\n            ['(', 'X_0', ')', '^2']\n\n        Args:\n            notation: The notation to use for the resulting list of tokens. One of \"prefix\", \"postfix\", or \"infix\".\n            symbol_library: The symbol library to use when converting the tree. This library defines the properties of the symbols in the tree.\n\n        Returns:\n            A list of tokens representing the tree rooted at this node in the specified notation.\n\n        Raises:\n             Exception: If the notation is not one of \"prefix\", \"postfix\", or \"infix\" or if a symbol is not in the symbol library.\n\n        Notes:\n            If the notation is \"infix\" and the symbol library is not provided, then the resulting list of tokens may contain unnecessary parentheses or have other issues.\n        \"\"\"\n        left = [] if self.left is None else self.left.to_list(notation, symbol_library)\n        right = [] if self.right is None else self.right.to_list(notation, symbol_library)\n\n        if notation == \"prefix\":\n            return [self.symbol] + left + right\n\n        elif notation == \"postfix\":\n            return left + right + [self.symbol]\n\n        elif notation == \"infix\" and symbol_library is None:\n            warnings.warn(\"Symbol library not provided. Generated expression may contain unnecessary parentheses and\"\n                          \" have other issues.\")\n            if self.left is None and self.right is None:\n                return [self.symbol]\n            if self.right is None and self.left is not None:\n                if self.symbol[0] == \"^\":\n                    return [\"(\"] + left + [\")\", self.symbol]\n                else:\n                    return [self.symbol, \"(\"] + left + [\")\"]\n            else:\n                if len(left) &gt; 1:\n                    left = [\"(\"] + left + [\")\"]\n                if len(right) &gt; 1:\n                    right = [\"(\"] + right + [\")\"]\n                return left + [self.symbol] + right\n\n        elif notation == \"infix\":\n            if is_float(self.symbol):\n                return [self.symbol]\n            if symbol_library.get_type(self.symbol) in [\"var\", \"const\", \"lit\"]:\n                return [self.symbol]\n            elif symbol_library.get_type(self.symbol) == \"fn\":\n                if symbol_library.get_precedence(self.symbol) &gt; 0:\n                    return [self.symbol, \"(\"] + left + [\")\"]\n                else:\n                    if len(left) &gt; 1:\n                        left = [\"(\"] + left + [\")\"]\n                    return left + [self.symbol]\n            elif symbol_library.get_type(self.symbol) == \"op\":\n                if not is_float(self.left.symbol) and -1 &lt; symbol_library.get_precedence(self.left.symbol) &lt;= symbol_library.get_precedence(self.symbol):\n                    left = [\"(\"] + left + [\")\"]\n                if not is_float(self.right.symbol) and -1 &lt; symbol_library.get_precedence(self.right.symbol) &lt;= symbol_library.get_precedence(self.symbol):\n                    right = [\"(\"] + right + [\")\"]\n                return left + [self.symbol] + right\n            else:\n                raise Exception(f\"Invalid symbol type for symbol {self.symbol}.\")\n        else:\n            raise Exception(\"Invalid notation selected. Use 'infix', 'prefix', 'postfix', or leave blank (defaults to 'infix').\")\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.Node.__init__","title":"<code>__init__(symbol=None, right=None, left=None)</code>","text":"<p>Initializes a Node object. We assume that nodes containing functions have only one child node, i.e. right is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n&gt;&gt;&gt; len(node)\n3\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol string stored in this node.</p> <code>None</code> <code>right</code> <code>Node</code> <p>The right child of this node.</p> <code>None</code> <code>left</code> <code>Node</code> <p>The left child of this node.</p> <code>None</code> <p>Functions:</p> Name Description <code>__len__</code> <p>Returns the number of nodes in the tree rooted at this node.</p> <code>__str__</code> <p>Returns a string representation of the tree rooted at this node.</p> <code>to_list</code> <p>str = \"infix\", symbol_library: SymbolLibrary = None): Returns a list representation of the tree rooted at this node.</p> Source code in <code>SRToolkit/utils/expression_tree.py</code> <pre><code>def __init__(self, symbol: str = None, right: \"Node\" = None, left: \"Node\" = None):\n    \"\"\"\n    Initializes a Node object. We assume that nodes containing functions have only one child node, i.e. right is None.\n\n    Examples:\n        &gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n        &gt;&gt;&gt; len(node)\n        3\n\n    Args:\n        symbol: The symbol string stored in this node.\n        right: The right child of this node.\n        left: The left child of this node.\n\n    Methods:\n        __len__(self):\n            Returns the number of nodes in the tree rooted at this node.\n        __str__(self):\n            Returns a string representation of the tree rooted at this node.\n        to_list(self, notation: str = \"infix\", symbol_library: SymbolLibrary = None):\n            Returns a list representation of the tree rooted at this node.\n\n    \"\"\"\n    self.symbol = symbol\n    self.right = right\n    self.left = left\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.Node.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of nodes in the tree rooted at this node.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n&gt;&gt;&gt; len(node)\n3\n</code></pre> <p>Returns:</p> Type Description <code>int</code> <p>The number of nodes in the tree rooted at this node.</p> Source code in <code>SRToolkit/utils/expression_tree.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of nodes in the tree rooted at this node.\n\n    Examples:\n        &gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n        &gt;&gt;&gt; len(node)\n        3\n\n    Returns:\n        The number of nodes in the tree rooted at this node.\n    \"\"\"\n    return (\n        1\n        + (len(self.left) if self.left is not None else 0)\n        + (len(self.right) if self.right is not None else 0)\n    )\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.Node.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string representation of the tree rooted at this node.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n&gt;&gt;&gt; str(node)\n'x+1'\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the tree rooted at this node.</p> Source code in <code>SRToolkit/utils/expression_tree.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a string representation of the tree rooted at this node.\n\n    Examples:\n        &gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n        &gt;&gt;&gt; str(node)\n        'x+1'\n\n    Returns:\n        A string representation of the tree rooted at this node.\n    \"\"\"\n    return \"\".join(self.to_list())\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.Node.to_list","title":"<code>to_list(notation='infix', symbol_library=None)</code>","text":"<p>Transforms the tree rooted at this node into a list of tokens.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = Node(\"+\", Node(\"X_0\"), Node(\"1\"))\n&gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n['1', '+', 'X_0']\n&gt;&gt;&gt; node.to_list(notation=\"postfix\")\n['1', 'X_0', '+']\n&gt;&gt;&gt; node.to_list(notation=\"prefix\")\n['+', '1', 'X_0']\n&gt;&gt;&gt; node = Node(\"+\", Node(\"*\", Node(\"X_0\"), Node(\"X_1\")), Node(\"1\"))\n&gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n['1', '+', 'X_1', '*', 'X_0']\n&gt;&gt;&gt; node.to_list(notation=\"infix\")\n['1', '+', '(', 'X_1', '*', 'X_0', ')']\n&gt;&gt;&gt; node = Node(\"sin\", None, Node(\"X_0\"))\n&gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n['sin', '(', 'X_0', ')']\n&gt;&gt;&gt; node = Node(\"^2\", None, Node(\"X_0\"))\n&gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n['X_0', '^2']\n&gt;&gt;&gt; node.to_list()\n['(', 'X_0', ')', '^2']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>notation</code> <code>str</code> <p>The notation to use for the resulting list of tokens. One of \"prefix\", \"postfix\", or \"infix\".</p> <code>'infix'</code> <code>symbol_library</code> <code>SymbolLibrary</code> <p>The symbol library to use when converting the tree. This library defines the properties of the symbols in the tree.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of tokens representing the tree rooted at this node in the specified notation.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the notation is not one of \"prefix\", \"postfix\", or \"infix\" or if a symbol is not in the symbol library.</p> Notes <p>If the notation is \"infix\" and the symbol library is not provided, then the resulting list of tokens may contain unnecessary parentheses or have other issues.</p> Source code in <code>SRToolkit/utils/expression_tree.py</code> <pre><code>def to_list(self, notation: str = \"infix\", symbol_library: SymbolLibrary = None) -&gt; List[str]:\n    \"\"\"\n    Transforms the tree rooted at this node into a list of tokens.\n\n    Examples:\n        &gt;&gt;&gt; node = Node(\"+\", Node(\"X_0\"), Node(\"1\"))\n        &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n        ['1', '+', 'X_0']\n        &gt;&gt;&gt; node.to_list(notation=\"postfix\")\n        ['1', 'X_0', '+']\n        &gt;&gt;&gt; node.to_list(notation=\"prefix\")\n        ['+', '1', 'X_0']\n        &gt;&gt;&gt; node = Node(\"+\", Node(\"*\", Node(\"X_0\"), Node(\"X_1\")), Node(\"1\"))\n        &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n        ['1', '+', 'X_1', '*', 'X_0']\n        &gt;&gt;&gt; node.to_list(notation=\"infix\")\n        ['1', '+', '(', 'X_1', '*', 'X_0', ')']\n        &gt;&gt;&gt; node = Node(\"sin\", None, Node(\"X_0\"))\n        &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n        ['sin', '(', 'X_0', ')']\n        &gt;&gt;&gt; node = Node(\"^2\", None, Node(\"X_0\"))\n        &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n        ['X_0', '^2']\n        &gt;&gt;&gt; node.to_list()\n        ['(', 'X_0', ')', '^2']\n\n    Args:\n        notation: The notation to use for the resulting list of tokens. One of \"prefix\", \"postfix\", or \"infix\".\n        symbol_library: The symbol library to use when converting the tree. This library defines the properties of the symbols in the tree.\n\n    Returns:\n        A list of tokens representing the tree rooted at this node in the specified notation.\n\n    Raises:\n         Exception: If the notation is not one of \"prefix\", \"postfix\", or \"infix\" or if a symbol is not in the symbol library.\n\n    Notes:\n        If the notation is \"infix\" and the symbol library is not provided, then the resulting list of tokens may contain unnecessary parentheses or have other issues.\n    \"\"\"\n    left = [] if self.left is None else self.left.to_list(notation, symbol_library)\n    right = [] if self.right is None else self.right.to_list(notation, symbol_library)\n\n    if notation == \"prefix\":\n        return [self.symbol] + left + right\n\n    elif notation == \"postfix\":\n        return left + right + [self.symbol]\n\n    elif notation == \"infix\" and symbol_library is None:\n        warnings.warn(\"Symbol library not provided. Generated expression may contain unnecessary parentheses and\"\n                      \" have other issues.\")\n        if self.left is None and self.right is None:\n            return [self.symbol]\n        if self.right is None and self.left is not None:\n            if self.symbol[0] == \"^\":\n                return [\"(\"] + left + [\")\", self.symbol]\n            else:\n                return [self.symbol, \"(\"] + left + [\")\"]\n        else:\n            if len(left) &gt; 1:\n                left = [\"(\"] + left + [\")\"]\n            if len(right) &gt; 1:\n                right = [\"(\"] + right + [\")\"]\n            return left + [self.symbol] + right\n\n    elif notation == \"infix\":\n        if is_float(self.symbol):\n            return [self.symbol]\n        if symbol_library.get_type(self.symbol) in [\"var\", \"const\", \"lit\"]:\n            return [self.symbol]\n        elif symbol_library.get_type(self.symbol) == \"fn\":\n            if symbol_library.get_precedence(self.symbol) &gt; 0:\n                return [self.symbol, \"(\"] + left + [\")\"]\n            else:\n                if len(left) &gt; 1:\n                    left = [\"(\"] + left + [\")\"]\n                return left + [self.symbol]\n        elif symbol_library.get_type(self.symbol) == \"op\":\n            if not is_float(self.left.symbol) and -1 &lt; symbol_library.get_precedence(self.left.symbol) &lt;= symbol_library.get_precedence(self.symbol):\n                left = [\"(\"] + left + [\")\"]\n            if not is_float(self.right.symbol) and -1 &lt; symbol_library.get_precedence(self.right.symbol) &lt;= symbol_library.get_precedence(self.symbol):\n                right = [\"(\"] + right + [\")\"]\n            return left + [self.symbol] + right\n        else:\n            raise Exception(f\"Invalid symbol type for symbol {self.symbol}.\")\n    else:\n        raise Exception(\"Invalid notation selected. Use 'infix', 'prefix', 'postfix', or leave blank (defaults to 'infix').\")\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.SymbolLibrary","title":"<code>SymbolLibrary</code>","text":"Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>class SymbolLibrary:\n    def __init__(self):\n        \"\"\"\n        Initializes an instance of the SymbolLibrary class. This class is used for managing symbols and their\n        properties for other functionality in this package.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary()\n            &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; library.get_type(\"x\")\n            'var'\n            &gt;&gt;&gt; library.get_precedence(\"x\")\n            0\n            &gt;&gt;&gt; library.get_np_fn(\"x\")\n            'x'\n            &gt;&gt;&gt; library.remove_symbol(\"x\")\n            &gt;&gt;&gt; library = SymbolLibrary.default_symbols()\n\n        Attributes:\n            symbols : dict\n                A dictionary mapping symbols to their properties (type, precedence, numpy function).\n\n        Methods:\n            add_symbol(symbol, symbol_type, precedence, np_fn):\n                Adds a symbol to the library.\n            remove_symbol(symbol):\n                Removes a symbol from the library.\n            get_type(symbol):\n                Retrieves the type of a symbol from the library.\n            get_precedence(symbol):\n                Returns the precedence of the given symbol.\n            get_np_fn(symbol):\n                Returns the numpy function corresponding to the given symbol.\n            default_symbols():\n                Returns a SymbolLibrary with the default symbols.\n        \"\"\"\n        self.symbols = dict()\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a string representation of the SymbolLibrary instance.\n\n        This method provides a comma-separated string of all the symbol keys\n        currently stored in the SymbolLibrary.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary()\n            &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; str(library)\n            'x'\n            &gt;&gt;&gt; library.add_symbol(\"sin\", \"fn\", 5, \"{} = np.sin({})\")\n            &gt;&gt;&gt; str(library)\n            'x, sin'\n\n        Returns:\n            A string containing all symbols in the library, separated by commas.\n        \"\"\"\n        return \", \".join(self.symbols.keys())\n\n    def __copy__(self) -&gt; \"SymbolLibrary\":\n        \"\"\"\n        Creates a copy of the SymbolLibrary instance.\n\n        Examples:\n            &gt;&gt;&gt; old_symbols = SymbolLibrary()\n            &gt;&gt;&gt; old_symbols.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; print(old_symbols)\n            x\n            &gt;&gt;&gt; new_symbols = copy.copy(old_symbols)\n            &gt;&gt;&gt; new_symbols.add_symbol(\"sin\", \"fn\", 5, \"{} = np.sin({})\")\n            &gt;&gt;&gt; print(old_symbols)\n            x\n            &gt;&gt;&gt; print(new_symbols)\n            x, sin\n\n        Returns:\n            A copy of the SymbolLibrary instance.\n        \"\"\"\n        sl = SymbolLibrary()\n        sl.symbols = copy.deepcopy(self.symbols)\n        return sl\n\n    def add_symbol(self, symbol: str, symbol_type: str, precedence: int, np_fn: str):\n        \"\"\"\n        Adds a symbol to the library. A symbol should have a type, precedence, and numpy function associated with it.\n        Type \"op\" should be used for symbols operating on two operands, \"fn\" for symbols operating on one operand,\n        \"lit\" for constants with a known value (such as pi or e), \"const\" for constants/parameters without a value that\n        need to be optimized, and \"var\" for variables whose values are provided as input data.\n\n        For example, look at the default_symbols function for the SymbolLibrary class.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary()\n            &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; library.add_symbol(\"sin\", \"fn\", 5, \"np.sin({})\")\n            &gt;&gt;&gt; library.add_symbol(\"C\", \"const\", 5, \"C[{}]\")\n            &gt;&gt;&gt; library.add_symbol(\"X\", \"var\", 5, \"X[:, 0]\")\n            &gt;&gt;&gt; library.add_symbol(\"pi\", \"lit\", 5, \"np.pi\")\n\n        Args:\n            symbol: The symbol to be added to the library.\n            symbol_type: The type of the symbol, one of \"op\" (operator), \"fn\" (function), \"lit\" (literal), \"const\" (constant), or \"var\" (variable).\n            precedence: The precedence of the symbol, used to determine the order of operations.\n            np_fn: A string representing the numpy function associated with this symbol.\n        \"\"\"\n        self.symbols[symbol] = {\n            \"symbol\": symbol,\n            \"type\": symbol_type,\n            \"precedence\": precedence,\n            \"np_fn\": np_fn,\n        }\n\n    def remove_symbol(self, symbol: str):\n        \"\"\"\n        Removes a symbol from the library.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary()\n            &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; len(library.symbols)\n            1\n            &gt;&gt;&gt; library.remove_symbol(\"x\")\n            &gt;&gt;&gt; len(library.symbols)\n            0\n\n        Args:\n            symbol: The symbol to be removed from the library.\n\n        Raises:\n            KeyError: If the symbol does not exist in the library.\n        \"\"\"\n        del self.symbols[symbol]\n\n    def get_type(self, symbol: str) -&gt; str:\n        \"\"\"\n        Retrieves the type of a symbol from the library.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary()\n            &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; library.get_type(\"x\")\n            'var'\n\n        Args:\n            symbol: The symbol whose type is to be retrieved.\n\n        Returns:\n            The type of the symbol if it exists in the library, otherwise an empty string.\n        \"\"\"\n        if symbol in self.symbols:\n            return self.symbols[symbol][\"type\"]\n        else:\n            return \"\"\n\n    def get_precedence(self, symbol: str) -&gt; int:\n        \"\"\"\n        Retrieves the precedence of the given symbol.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary()\n            &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; library.get_precedence(\"x\")\n            0\n\n        Args:\n            symbol: The symbol whose precedence is to be retrieved.\n\n        Returns:\n            The precedence of the symbol if it exists in the library, otherwise -1.\n        \"\"\"\n        if symbol in self.symbols:\n            return self.symbols[symbol][\"precedence\"]\n        else:\n            return -1\n\n    def get_np_fn(self, symbol: str) -&gt; str:\n        \"\"\"\n        Returns the numpy function corresponding to the given symbol.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary()\n            &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; library.get_np_fn(\"x\")\n            'x'\n\n        Args:\n            symbol: The symbol to look up.\n\n        Returns:\n            The numpy function corresponding to the given symbol, or an empty string if the symbol was not found.\n        \"\"\"\n        if symbol in self.symbols:\n            return self.symbols[symbol][\"np_fn\"]\n        else:\n            return \"\"\n\n    @staticmethod\n    def default_symbols(num_variables: int = 25) -&gt; \"SymbolLibrary\":\n        \"\"\"\n        Creates a SymbolLibrary instance populated with default mathematical symbols.\n\n        This method adds a set of predefined symbols to a SymbolLibrary instance,\n        representing common mathematical operations, functions, constants, and optional\n        variables. The symbols include basic arithmetic operations, trigonometric and\n        exponential functions, and mathematical constants like pi and e.\n\n        If num_variables is greater than 0, it adds variables labeled 'X_0' to 'X_{num_variables-1}', each\n         associated with a column in a data array X.\n\n        Note: The variables in the default_symbols function are added in the predefined order,\n        which is the same order as the columns in the data array X.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary.default_symbols()\n            &gt;&gt;&gt; len(library.symbols)\n            44\n\n        Args:\n            num_variables: The number of variables to add to the library (default is 25).\n\n        Returns:\n            A SymbolLibrary instance populated with default mathematical symbols.\n        \"\"\"\n        sl = SymbolLibrary()\n        sl.add_symbol(\"+\", symbol_type=\"op\", precedence=0, np_fn=\"{} = {} + {}\")\n        sl.add_symbol(\"-\", symbol_type=\"op\", precedence=0, np_fn=\"{} = {} - {}\")\n        sl.add_symbol(\"*\", symbol_type=\"op\", precedence=1, np_fn=\"{} = {} * {}\")\n        sl.add_symbol(\"/\", symbol_type=\"op\", precedence=1, np_fn=\"{} = {} / {}\")\n        sl.add_symbol(\"^\", symbol_type=\"op\", precedence=2, np_fn=\"{} = np.pow({},{})\")\n        sl.add_symbol(\"u-\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = -{}\")\n        sl.add_symbol(\"sqrt\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.sqrt({})\")\n        sl.add_symbol(\"sin\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.sin({})\")\n        sl.add_symbol(\"cos\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.cos({})\")\n        sl.add_symbol(\"exp\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.exp({})\")\n        sl.add_symbol(\"ln\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.log({})\")\n        sl.add_symbol(\"log\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.log10({})\")\n        sl.add_symbol(\"^-1\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = 1/{}\")\n        sl.add_symbol(\"^2\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**2\")\n        sl.add_symbol(\"^3\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**3\")\n        sl.add_symbol(\"^4\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**4\")\n        sl.add_symbol(\"^5\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**5\")\n        sl.add_symbol(\"pi\", symbol_type=\"lit\", precedence=5, np_fn=\"np.pi\")\n        sl.add_symbol(\"e\", symbol_type=\"lit\", precedence=5, np_fn=\"np.e\")\n        sl.add_symbol(\"C\", symbol_type=\"const\", precedence=5, np_fn=\"C[{}]\")\n\n        if num_variables &gt; 0:\n            for i in range(num_variables):\n                sl.add_symbol(f\"X_{i}\", \"var\", 5, \"X[:, {}]\".format(i))\n\n        return sl\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.SymbolLibrary.__init__","title":"<code>__init__()</code>","text":"<p>Initializes an instance of the SymbolLibrary class. This class is used for managing symbols and their properties for other functionality in this package.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary()\n&gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; library.get_type(\"x\")\n'var'\n&gt;&gt;&gt; library.get_precedence(\"x\")\n0\n&gt;&gt;&gt; library.get_np_fn(\"x\")\n'x'\n&gt;&gt;&gt; library.remove_symbol(\"x\")\n&gt;&gt;&gt; library = SymbolLibrary.default_symbols()\n</code></pre> <p>Attributes:</p> Name Type Description <code>symbols</code> <p>dict A dictionary mapping symbols to their properties (type, precedence, numpy function).</p> <p>Functions:</p> Name Description <code>add_symbol</code> <p>Adds a symbol to the library.</p> <code>remove_symbol</code> <p>Removes a symbol from the library.</p> <code>get_type</code> <p>Retrieves the type of a symbol from the library.</p> <code>get_precedence</code> <p>Returns the precedence of the given symbol.</p> <code>get_np_fn</code> <p>Returns the numpy function corresponding to the given symbol.</p> <code>default_symbols</code> <p>Returns a SymbolLibrary with the default symbols.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes an instance of the SymbolLibrary class. This class is used for managing symbols and their\n    properties for other functionality in this package.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary()\n        &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; library.get_type(\"x\")\n        'var'\n        &gt;&gt;&gt; library.get_precedence(\"x\")\n        0\n        &gt;&gt;&gt; library.get_np_fn(\"x\")\n        'x'\n        &gt;&gt;&gt; library.remove_symbol(\"x\")\n        &gt;&gt;&gt; library = SymbolLibrary.default_symbols()\n\n    Attributes:\n        symbols : dict\n            A dictionary mapping symbols to their properties (type, precedence, numpy function).\n\n    Methods:\n        add_symbol(symbol, symbol_type, precedence, np_fn):\n            Adds a symbol to the library.\n        remove_symbol(symbol):\n            Removes a symbol from the library.\n        get_type(symbol):\n            Retrieves the type of a symbol from the library.\n        get_precedence(symbol):\n            Returns the precedence of the given symbol.\n        get_np_fn(symbol):\n            Returns the numpy function corresponding to the given symbol.\n        default_symbols():\n            Returns a SymbolLibrary with the default symbols.\n    \"\"\"\n    self.symbols = dict()\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.SymbolLibrary.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string representation of the SymbolLibrary instance.</p> <p>This method provides a comma-separated string of all the symbol keys currently stored in the SymbolLibrary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary()\n&gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; str(library)\n'x'\n&gt;&gt;&gt; library.add_symbol(\"sin\", \"fn\", 5, \"{} = np.sin({})\")\n&gt;&gt;&gt; str(library)\n'x, sin'\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>A string containing all symbols in the library, separated by commas.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a string representation of the SymbolLibrary instance.\n\n    This method provides a comma-separated string of all the symbol keys\n    currently stored in the SymbolLibrary.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary()\n        &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; str(library)\n        'x'\n        &gt;&gt;&gt; library.add_symbol(\"sin\", \"fn\", 5, \"{} = np.sin({})\")\n        &gt;&gt;&gt; str(library)\n        'x, sin'\n\n    Returns:\n        A string containing all symbols in the library, separated by commas.\n    \"\"\"\n    return \", \".join(self.symbols.keys())\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.SymbolLibrary.__copy__","title":"<code>__copy__()</code>","text":"<p>Creates a copy of the SymbolLibrary instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; old_symbols = SymbolLibrary()\n&gt;&gt;&gt; old_symbols.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; print(old_symbols)\nx\n&gt;&gt;&gt; new_symbols = copy.copy(old_symbols)\n&gt;&gt;&gt; new_symbols.add_symbol(\"sin\", \"fn\", 5, \"{} = np.sin({})\")\n&gt;&gt;&gt; print(old_symbols)\nx\n&gt;&gt;&gt; print(new_symbols)\nx, sin\n</code></pre> <p>Returns:</p> Type Description <code>SymbolLibrary</code> <p>A copy of the SymbolLibrary instance.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def __copy__(self) -&gt; \"SymbolLibrary\":\n    \"\"\"\n    Creates a copy of the SymbolLibrary instance.\n\n    Examples:\n        &gt;&gt;&gt; old_symbols = SymbolLibrary()\n        &gt;&gt;&gt; old_symbols.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; print(old_symbols)\n        x\n        &gt;&gt;&gt; new_symbols = copy.copy(old_symbols)\n        &gt;&gt;&gt; new_symbols.add_symbol(\"sin\", \"fn\", 5, \"{} = np.sin({})\")\n        &gt;&gt;&gt; print(old_symbols)\n        x\n        &gt;&gt;&gt; print(new_symbols)\n        x, sin\n\n    Returns:\n        A copy of the SymbolLibrary instance.\n    \"\"\"\n    sl = SymbolLibrary()\n    sl.symbols = copy.deepcopy(self.symbols)\n    return sl\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.SymbolLibrary.add_symbol","title":"<code>add_symbol(symbol, symbol_type, precedence, np_fn)</code>","text":"<p>Adds a symbol to the library. A symbol should have a type, precedence, and numpy function associated with it. Type \"op\" should be used for symbols operating on two operands, \"fn\" for symbols operating on one operand, \"lit\" for constants with a known value (such as pi or e), \"const\" for constants/parameters without a value that need to be optimized, and \"var\" for variables whose values are provided as input data.</p> <p>For example, look at the default_symbols function for the SymbolLibrary class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary()\n&gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; library.add_symbol(\"sin\", \"fn\", 5, \"np.sin({})\")\n&gt;&gt;&gt; library.add_symbol(\"C\", \"const\", 5, \"C[{}]\")\n&gt;&gt;&gt; library.add_symbol(\"X\", \"var\", 5, \"X[:, 0]\")\n&gt;&gt;&gt; library.add_symbol(\"pi\", \"lit\", 5, \"np.pi\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol to be added to the library.</p> required <code>symbol_type</code> <code>str</code> <p>The type of the symbol, one of \"op\" (operator), \"fn\" (function), \"lit\" (literal), \"const\" (constant), or \"var\" (variable).</p> required <code>precedence</code> <code>int</code> <p>The precedence of the symbol, used to determine the order of operations.</p> required <code>np_fn</code> <code>str</code> <p>A string representing the numpy function associated with this symbol.</p> required Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def add_symbol(self, symbol: str, symbol_type: str, precedence: int, np_fn: str):\n    \"\"\"\n    Adds a symbol to the library. A symbol should have a type, precedence, and numpy function associated with it.\n    Type \"op\" should be used for symbols operating on two operands, \"fn\" for symbols operating on one operand,\n    \"lit\" for constants with a known value (such as pi or e), \"const\" for constants/parameters without a value that\n    need to be optimized, and \"var\" for variables whose values are provided as input data.\n\n    For example, look at the default_symbols function for the SymbolLibrary class.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary()\n        &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; library.add_symbol(\"sin\", \"fn\", 5, \"np.sin({})\")\n        &gt;&gt;&gt; library.add_symbol(\"C\", \"const\", 5, \"C[{}]\")\n        &gt;&gt;&gt; library.add_symbol(\"X\", \"var\", 5, \"X[:, 0]\")\n        &gt;&gt;&gt; library.add_symbol(\"pi\", \"lit\", 5, \"np.pi\")\n\n    Args:\n        symbol: The symbol to be added to the library.\n        symbol_type: The type of the symbol, one of \"op\" (operator), \"fn\" (function), \"lit\" (literal), \"const\" (constant), or \"var\" (variable).\n        precedence: The precedence of the symbol, used to determine the order of operations.\n        np_fn: A string representing the numpy function associated with this symbol.\n    \"\"\"\n    self.symbols[symbol] = {\n        \"symbol\": symbol,\n        \"type\": symbol_type,\n        \"precedence\": precedence,\n        \"np_fn\": np_fn,\n    }\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.SymbolLibrary.remove_symbol","title":"<code>remove_symbol(symbol)</code>","text":"<p>Removes a symbol from the library.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary()\n&gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; len(library.symbols)\n1\n&gt;&gt;&gt; library.remove_symbol(\"x\")\n&gt;&gt;&gt; len(library.symbols)\n0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol to be removed from the library.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the symbol does not exist in the library.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def remove_symbol(self, symbol: str):\n    \"\"\"\n    Removes a symbol from the library.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary()\n        &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; len(library.symbols)\n        1\n        &gt;&gt;&gt; library.remove_symbol(\"x\")\n        &gt;&gt;&gt; len(library.symbols)\n        0\n\n    Args:\n        symbol: The symbol to be removed from the library.\n\n    Raises:\n        KeyError: If the symbol does not exist in the library.\n    \"\"\"\n    del self.symbols[symbol]\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.SymbolLibrary.get_type","title":"<code>get_type(symbol)</code>","text":"<p>Retrieves the type of a symbol from the library.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary()\n&gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; library.get_type(\"x\")\n'var'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol whose type is to be retrieved.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The type of the symbol if it exists in the library, otherwise an empty string.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def get_type(self, symbol: str) -&gt; str:\n    \"\"\"\n    Retrieves the type of a symbol from the library.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary()\n        &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; library.get_type(\"x\")\n        'var'\n\n    Args:\n        symbol: The symbol whose type is to be retrieved.\n\n    Returns:\n        The type of the symbol if it exists in the library, otherwise an empty string.\n    \"\"\"\n    if symbol in self.symbols:\n        return self.symbols[symbol][\"type\"]\n    else:\n        return \"\"\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.SymbolLibrary.get_precedence","title":"<code>get_precedence(symbol)</code>","text":"<p>Retrieves the precedence of the given symbol.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary()\n&gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; library.get_precedence(\"x\")\n0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol whose precedence is to be retrieved.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The precedence of the symbol if it exists in the library, otherwise -1.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def get_precedence(self, symbol: str) -&gt; int:\n    \"\"\"\n    Retrieves the precedence of the given symbol.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary()\n        &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; library.get_precedence(\"x\")\n        0\n\n    Args:\n        symbol: The symbol whose precedence is to be retrieved.\n\n    Returns:\n        The precedence of the symbol if it exists in the library, otherwise -1.\n    \"\"\"\n    if symbol in self.symbols:\n        return self.symbols[symbol][\"precedence\"]\n    else:\n        return -1\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.SymbolLibrary.get_np_fn","title":"<code>get_np_fn(symbol)</code>","text":"<p>Returns the numpy function corresponding to the given symbol.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary()\n&gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; library.get_np_fn(\"x\")\n'x'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol to look up.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The numpy function corresponding to the given symbol, or an empty string if the symbol was not found.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def get_np_fn(self, symbol: str) -&gt; str:\n    \"\"\"\n    Returns the numpy function corresponding to the given symbol.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary()\n        &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; library.get_np_fn(\"x\")\n        'x'\n\n    Args:\n        symbol: The symbol to look up.\n\n    Returns:\n        The numpy function corresponding to the given symbol, or an empty string if the symbol was not found.\n    \"\"\"\n    if symbol in self.symbols:\n        return self.symbols[symbol][\"np_fn\"]\n    else:\n        return \"\"\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.SymbolLibrary.default_symbols","title":"<code>default_symbols(num_variables=25)</code>  <code>staticmethod</code>","text":"<p>Creates a SymbolLibrary instance populated with default mathematical symbols.</p> <p>This method adds a set of predefined symbols to a SymbolLibrary instance, representing common mathematical operations, functions, constants, and optional variables. The symbols include basic arithmetic operations, trigonometric and exponential functions, and mathematical constants like pi and e.</p> <p>If num_variables is greater than 0, it adds variables labeled 'X_0' to 'X_{num_variables-1}', each  associated with a column in a data array X.</p> <p>Note: The variables in the default_symbols function are added in the predefined order, which is the same order as the columns in the data array X.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary.default_symbols()\n&gt;&gt;&gt; len(library.symbols)\n44\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>num_variables</code> <code>int</code> <p>The number of variables to add to the library (default is 25).</p> <code>25</code> <p>Returns:</p> Type Description <code>SymbolLibrary</code> <p>A SymbolLibrary instance populated with default mathematical symbols.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>@staticmethod\ndef default_symbols(num_variables: int = 25) -&gt; \"SymbolLibrary\":\n    \"\"\"\n    Creates a SymbolLibrary instance populated with default mathematical symbols.\n\n    This method adds a set of predefined symbols to a SymbolLibrary instance,\n    representing common mathematical operations, functions, constants, and optional\n    variables. The symbols include basic arithmetic operations, trigonometric and\n    exponential functions, and mathematical constants like pi and e.\n\n    If num_variables is greater than 0, it adds variables labeled 'X_0' to 'X_{num_variables-1}', each\n     associated with a column in a data array X.\n\n    Note: The variables in the default_symbols function are added in the predefined order,\n    which is the same order as the columns in the data array X.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary.default_symbols()\n        &gt;&gt;&gt; len(library.symbols)\n        44\n\n    Args:\n        num_variables: The number of variables to add to the library (default is 25).\n\n    Returns:\n        A SymbolLibrary instance populated with default mathematical symbols.\n    \"\"\"\n    sl = SymbolLibrary()\n    sl.add_symbol(\"+\", symbol_type=\"op\", precedence=0, np_fn=\"{} = {} + {}\")\n    sl.add_symbol(\"-\", symbol_type=\"op\", precedence=0, np_fn=\"{} = {} - {}\")\n    sl.add_symbol(\"*\", symbol_type=\"op\", precedence=1, np_fn=\"{} = {} * {}\")\n    sl.add_symbol(\"/\", symbol_type=\"op\", precedence=1, np_fn=\"{} = {} / {}\")\n    sl.add_symbol(\"^\", symbol_type=\"op\", precedence=2, np_fn=\"{} = np.pow({},{})\")\n    sl.add_symbol(\"u-\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = -{}\")\n    sl.add_symbol(\"sqrt\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.sqrt({})\")\n    sl.add_symbol(\"sin\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.sin({})\")\n    sl.add_symbol(\"cos\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.cos({})\")\n    sl.add_symbol(\"exp\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.exp({})\")\n    sl.add_symbol(\"ln\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.log({})\")\n    sl.add_symbol(\"log\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.log10({})\")\n    sl.add_symbol(\"^-1\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = 1/{}\")\n    sl.add_symbol(\"^2\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**2\")\n    sl.add_symbol(\"^3\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**3\")\n    sl.add_symbol(\"^4\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**4\")\n    sl.add_symbol(\"^5\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**5\")\n    sl.add_symbol(\"pi\", symbol_type=\"lit\", precedence=5, np_fn=\"np.pi\")\n    sl.add_symbol(\"e\", symbol_type=\"lit\", precedence=5, np_fn=\"np.e\")\n    sl.add_symbol(\"C\", symbol_type=\"const\", precedence=5, np_fn=\"C[{}]\")\n\n    if num_variables &gt; 0:\n        for i in range(num_variables):\n            sl.add_symbol(f\"X_{i}\", \"var\", 5, \"X[:, {}]\".format(i))\n\n    return sl\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.tokens_to_tree","title":"<code>tokens_to_tree(tokens, sl)</code>","text":"<p>Converts a list of tokens to a tree data structure. Throws an exception if the expression is invalid (check syntax and that all symbols are in the symbol library correctly defined).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tree = tokens_to_tree([\"(\", \"x\", \"+\", \"y\", \")\"], SymbolLibrary.default_symbols())\n&gt;&gt;&gt; len(tree)\n3\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>List[str]</code> <p>The list of tokens to convert.</p> required <code>sl</code> <code>SymbolLibrary</code> <p>The symbol library to use when parsing the tokens.</p> required <p>Returns:</p> Type Description <code>Node</code> <p>The root of the expression tree data structure.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the expression is invalid. Usually this means that a symbol is not in the symbol library or that        there is a syntactic error in the expression.</p> Source code in <code>SRToolkit/utils/expression_tree.py</code> <pre><code>def tokens_to_tree(tokens: List[str], sl: SymbolLibrary) -&gt; Node:\n    \"\"\"\n    Converts a list of tokens to a tree data structure. Throws an exception if the expression is invalid (check syntax\n    and that all symbols are in the symbol library correctly defined).\n\n    Examples:\n        &gt;&gt;&gt; tree = tokens_to_tree([\"(\", \"x\", \"+\", \"y\", \")\"], SymbolLibrary.default_symbols())\n        &gt;&gt;&gt; len(tree)\n        3\n\n    Args:\n        tokens: The list of tokens to convert.\n        sl: The symbol library to use when parsing the tokens.\n\n    Returns:\n        The root of the expression tree data structure.\n\n    Raises:\n        Exception: If the expression is invalid. Usually this means that a symbol is not in the symbol library or that\n                   there is a syntactic error in the expression.\n    \"\"\"\n    num_tokens = len([t for t in tokens if t != \"(\" and t != \")\"])\n    expr_str = \"\".join(tokens)\n    tokens = [\"(\"] + tokens + [\")\"]\n    operator_stack = []\n    out_stack = []\n    for token in tokens:\n        if token == \"(\":\n            operator_stack.append(token)\n        elif sl.get_type(token) in [\"var\", \"const\", \"lit\"] or is_float(token):\n            out_stack.append(Node(token))\n        elif sl.get_type(token) == \"fn\":\n            if token[0] == \"^\":\n                out_stack.append(Node(token, left=out_stack.pop()))\n            else:\n                operator_stack.append(token)\n        elif sl.get_type(token) == \"op\":\n            while (\n                len(operator_stack) &gt; 0\n                and operator_stack[-1] != \"(\"\n                and sl.get_precedence(operator_stack[-1]) &gt; sl.get_precedence(token)\n            ):\n                if sl.get_type(operator_stack[-1]) == \"fn\":\n                    out_stack.append(Node(operator_stack.pop(), left=out_stack.pop()))\n                else:\n                    out_stack.append(\n                        Node(operator_stack.pop(), out_stack.pop(), out_stack.pop())\n                    )\n            operator_stack.append(token)\n        else:\n            while len(operator_stack) &gt; 0 and operator_stack[-1] != \"(\":\n                if sl.get_type(operator_stack[-1]) == \"fn\":\n                    out_stack.append(Node(operator_stack.pop(), left=out_stack.pop()))\n                else:\n                    out_stack.append(\n                        Node(operator_stack.pop(), out_stack.pop(), out_stack.pop())\n                    )\n            operator_stack.pop()\n            if len(operator_stack) &gt; 0 and sl.get_type(operator_stack[-1]) == \"fn\":\n                out_stack.append(Node(operator_stack.pop(), left=out_stack.pop()))\n    if len(out_stack[-1]) == num_tokens:\n        return out_stack[-1]\n    else:\n        raise Exception(f\"Error while parsing expression {expr_str}.\")\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.is_float","title":"<code>is_float(element)</code>","text":"<p>Checks if a given element is a float.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_float(1.0)\nTrue\n&gt;&gt;&gt; is_float(\"1.0\")\nTrue\n&gt;&gt;&gt; is_float(\"1\")\nTrue\n&gt;&gt;&gt; is_float(None)\nFalse\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>any</code> <p>The element to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the element is a float, False otherwise.</p> Source code in <code>SRToolkit/utils/expression_tree.py</code> <pre><code>def is_float(element: any) -&gt; bool:\n    \"\"\"\n    Checks if a given element is a float.\n\n    Examples:\n        &gt;&gt;&gt; is_float(1.0)\n        True\n        &gt;&gt;&gt; is_float(\"1.0\")\n        True\n        &gt;&gt;&gt; is_float(\"1\")\n        True\n        &gt;&gt;&gt; is_float(None)\n        False\n\n\n    Args:\n        element: The element to check.\n\n    Returns:\n        True if the element is a float, False otherwise.\n    \"\"\"\n    if element is None:\n        return False\n    try:\n        float(element)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.tree_to_function_rec","title":"<code>tree_to_function_rec(tree, symbol_library, var_counter=0, const_counter=0)</code>","text":"<p>Recursively converts a parse tree into a string of Python code that can be executed to evaluate the expression represented by the tree.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>The root of the parse tree to convert.</p> required <code>symbol_library</code> <code>SymbolLibrary</code> <p>The symbol library to use when converting the tree. This library defines the properties of the symbols in the tree.</p> required <code>var_counter</code> <code>int</code> <p>The number of variables encountered so far. This is used to create a unique variable name for each variable.</p> <code>0</code> <code>const_counter</code> <code>int</code> <p>The number of constants encountered so far. This is used to select the correct constant value from the constant array.</p> <code>0</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of strings, where each string contains a line of Python code to execute to evaluate the expression represented by the tree.</p> <code>str</code> <p>The name of the variable that represents the output of the expression.</p> <code>int</code> <p>The updated value of <code>var_counter</code>.</p> <code>int</code> <p>The updated value of <code>const_counter</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the parse tree contains an invalid symbol.</p> Notes <p>This function is a helper function for <code>expr_to_executable_function</code> and similar and should not be called directly unless you want to customize the way the expression is defined. For examples, see the code of <code>expr_to_executable_function</code> and <code>expr_to_error_function</code> in this module.</p> Source code in <code>SRToolkit/utils/expression_compiler.py</code> <pre><code>def tree_to_function_rec(tree: Node, symbol_library: SymbolLibrary, var_counter: int=0, const_counter: int=0) -&gt; Tuple[List[str], str, int, int]:\n    \"\"\"\n    Recursively converts a parse tree into a string of Python code that can be executed to evaluate the expression\n    represented by the tree.\n\n    Args:\n        tree: The root of the parse tree to convert.\n        symbol_library: The symbol library to use when converting the tree. This library defines the properties of the symbols in the tree.\n        var_counter: The number of variables encountered so far. This is used to create a unique variable name for each variable.\n        const_counter: The number of constants encountered so far. This is used to select the correct constant value from the constant array.\n\n    Returns:\n        A list of strings, where each string contains a line of Python code to execute to evaluate the expression represented by the tree.\n        The name of the variable that represents the output of the expression.\n        The updated value of `var_counter`.\n        The updated value of `const_counter`.\n\n    Raises:\n        Exception: If the parse tree contains an invalid symbol.\n\n    Notes:\n        This function is a helper function for `expr_to_executable_function` and similar and should not be called directly\n        unless you want to customize the way the expression is defined. For examples, see the code of `expr_to_executable_function` and `expr_to_error_function` in this module.\n\n\n    \"\"\"\n    if tree.left is None and tree.right is None:\n        if symbol_library.get_type(tree.symbol) in [\"var\", \"lit\"]:\n            return [], symbol_library.get_np_fn(tree.symbol), var_counter, const_counter\n        elif symbol_library.get_type(tree.symbol) == \"const\":\n            return [], symbol_library.get_np_fn(tree.symbol).format(const_counter), var_counter, const_counter + 1\n        else:\n            if is_float(tree.symbol):\n                return [], tree.symbol, var_counter, const_counter\n            else:\n                raise Exception(f\"Encountered invalid symbol {tree.symbol} while converting to function.\")\n\n    elif tree.left is not None and tree.right is None:\n        code, symbol, var_counter, const_counter = tree_to_function_rec(tree.left, symbol_library, var_counter, const_counter)\n        output_symbol = \"y_{}\".format(var_counter)\n        code.append(symbol_library.get_np_fn(tree.symbol).format(output_symbol, symbol))\n        return code, output_symbol, var_counter + 1, const_counter\n\n    else:\n        left_code, left_symbol, var_counter, const_counter = tree_to_function_rec(tree.left, symbol_library, var_counter, const_counter)\n        right_code, right_symbol, var_counter, const_counter = tree_to_function_rec(tree.right, symbol_library, var_counter, const_counter)\n        output_symbol = \"y_{}\".format(var_counter)\n        code = left_code + right_code\n        code.append(symbol_library.get_np_fn(tree.symbol).format(output_symbol, left_symbol, right_symbol))\n        return code, output_symbol, var_counter + 1, const_counter\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.expr_to_executable_function","title":"<code>expr_to_executable_function(expr, symbol_library=SymbolLibrary.default_symbols())</code>","text":"<p>Converts an expression in infix notation to an executable function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; executable_fun = expr_to_executable_function([\"A\", \"+\", \"1\"])\n&gt;&gt;&gt; executable_fun(np.array([[1], [2], [3], [4]]), np.array([]))\narray([2, 3, 4, 5])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>expr</code> <p>The expression in infix notation.</p> required <code>symbol_library</code> <p>The symbol library to use. Defaults to SymbolLibrary.default_symbols().</p> <code>default_symbols()</code> <p>Returns:</p> Type Description <code>callable</code> <p>An executable function that takes in a 2D array of input values and a 1D array of constant values and returns the output of the expression.</p> Source code in <code>SRToolkit/utils/expression_compiler.py</code> <pre><code>def expr_to_executable_function(expr: List[str], symbol_library: SymbolLibrary=SymbolLibrary.default_symbols()) -&gt; callable:\n    \"\"\"\n    Converts an expression in infix notation to an executable function.\n\n    Examples:\n        &gt;&gt;&gt; executable_fun = expr_to_executable_function([\"A\", \"+\", \"1\"])\n        &gt;&gt;&gt; executable_fun(np.array([[1], [2], [3], [4]]), np.array([]))\n        array([2, 3, 4, 5])\n\n    Args:\n        expr : The expression in infix notation.\n        symbol_library : The symbol library to use. Defaults to SymbolLibrary.default_symbols().\n\n    Returns:\n        An executable function that takes in a 2D array of input values and a 1D array of constant values and returns the output of the expression.\n    \"\"\"\n    tree = tokens_to_tree(expr, symbol_library)\n    code, symbol, var_counter, const_counter = tree_to_function_rec(tree, symbol_library)\n\n    fun_string = \"def _executable_expression_(X, C):\\n\"\n    for c in code:\n        fun_string += \"\\t\" + c + \"\\n\"\n    fun_string += \"\\treturn \" + symbol\n\n    exec(fun_string)\n    return locals()[\"_executable_expression_\"]\n</code></pre>"},{"location":"references/utils/#SRToolkit.utils.expr_to_error_function","title":"<code>expr_to_error_function(expr, symbol_library=SymbolLibrary.default_symbols())</code>","text":"<p>Converts an expression in infix notation to an executable function that returns the root mean squared error between the output of the expression and the target values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; executable_fun = expr_to_error_function([\"X_0\", \"+\", \"1\"])\n&gt;&gt;&gt; executable_fun(np.array([[1], [2], [3], [4]]), np.array([]), np.array([2, 3, 4, 5]))\n0.0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>expr</code> <p>The expression in infix notation.</p> required <code>symbol_library</code> <p>The symbol library to use. Defaults to SymbolLibrary.default_symbols().</p> <code>default_symbols()</code> <p>Returns:</p> Type Description <code>callable</code> <p>An executable function that takes in a 2D array of input values <code>X</code>, a 1D array of constant values <code>C</code>, and a 1D array of target values <code>y</code>. It returns the root mean squared error between the output of the expression and the target values.</p> Source code in <code>SRToolkit/utils/expression_compiler.py</code> <pre><code>def expr_to_error_function(expr: List[str], symbol_library: SymbolLibrary=SymbolLibrary.default_symbols()) -&gt; callable:\n    \"\"\"\n    Converts an expression in infix notation to an executable function that returns the root mean squared error between\n    the output of the expression and the target values.\n\n    Examples:\n        &gt;&gt;&gt; executable_fun = expr_to_error_function([\"X_0\", \"+\", \"1\"])\n        &gt;&gt;&gt; executable_fun(np.array([[1], [2], [3], [4]]), np.array([]), np.array([2, 3, 4, 5]))\n        0.0\n\n    Args:\n        expr : The expression in infix notation.\n        symbol_library : The symbol library to use. Defaults to SymbolLibrary.default_symbols().\n\n    Returns:\n        An executable function that takes in a 2D array of input values `X`, a 1D array of constant values `C`, and a 1D array of target values `y`. It returns the root mean squared error between the output of the expression and the target values.\n    \"\"\"\n    tree = tokens_to_tree(expr, symbol_library)\n    code, symbol, var_counter, const_counter = tree_to_function_rec(tree, symbol_library)\n\n    fun_string = \"def _executable_expression_(X, C, y):\\n\"\n    for c in code:\n        fun_string += \"\\t\" + c + \"\\n\"\n    fun_string += f\"\\treturn np.sqrt(np.mean(({symbol}-y)**2))\"\n\n    exec(fun_string)\n    return locals()[\"_executable_expression_\"]\n</code></pre>"},{"location":"references/utils/expression_compiler/","title":"Expression Compiler Module","text":""},{"location":"references/utils/expression_compiler/#SRToolkit.utils.expression_compiler","title":"<code>SRToolkit.utils.expression_compiler</code>","text":"<p>This module contains functions that convert an expression in infix notation to an executable python function.</p>"},{"location":"references/utils/expression_compiler/#SRToolkit.utils.expression_compiler.expr_to_executable_function","title":"<code>expr_to_executable_function(expr, symbol_library=SymbolLibrary.default_symbols())</code>","text":"<p>Converts an expression in infix notation to an executable function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; executable_fun = expr_to_executable_function([\"A\", \"+\", \"1\"])\n&gt;&gt;&gt; executable_fun(np.array([[1], [2], [3], [4]]), np.array([]))\narray([2, 3, 4, 5])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>expr</code> <p>The expression in infix notation.</p> required <code>symbol_library</code> <p>The symbol library to use. Defaults to SymbolLibrary.default_symbols().</p> <code>default_symbols()</code> <p>Returns:</p> Type Description <code>callable</code> <p>An executable function that takes in a 2D array of input values and a 1D array of constant values and returns the output of the expression.</p> Source code in <code>SRToolkit/utils/expression_compiler.py</code> <pre><code>def expr_to_executable_function(expr: List[str], symbol_library: SymbolLibrary=SymbolLibrary.default_symbols()) -&gt; callable:\n    \"\"\"\n    Converts an expression in infix notation to an executable function.\n\n    Examples:\n        &gt;&gt;&gt; executable_fun = expr_to_executable_function([\"A\", \"+\", \"1\"])\n        &gt;&gt;&gt; executable_fun(np.array([[1], [2], [3], [4]]), np.array([]))\n        array([2, 3, 4, 5])\n\n    Args:\n        expr : The expression in infix notation.\n        symbol_library : The symbol library to use. Defaults to SymbolLibrary.default_symbols().\n\n    Returns:\n        An executable function that takes in a 2D array of input values and a 1D array of constant values and returns the output of the expression.\n    \"\"\"\n    tree = tokens_to_tree(expr, symbol_library)\n    code, symbol, var_counter, const_counter = tree_to_function_rec(tree, symbol_library)\n\n    fun_string = \"def _executable_expression_(X, C):\\n\"\n    for c in code:\n        fun_string += \"\\t\" + c + \"\\n\"\n    fun_string += \"\\treturn \" + symbol\n\n    exec(fun_string)\n    return locals()[\"_executable_expression_\"]\n</code></pre>"},{"location":"references/utils/expression_compiler/#SRToolkit.utils.expression_compiler.expr_to_error_function","title":"<code>expr_to_error_function(expr, symbol_library=SymbolLibrary.default_symbols())</code>","text":"<p>Converts an expression in infix notation to an executable function that returns the root mean squared error between the output of the expression and the target values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; executable_fun = expr_to_error_function([\"X_0\", \"+\", \"1\"])\n&gt;&gt;&gt; executable_fun(np.array([[1], [2], [3], [4]]), np.array([]), np.array([2, 3, 4, 5]))\n0.0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>expr</code> <p>The expression in infix notation.</p> required <code>symbol_library</code> <p>The symbol library to use. Defaults to SymbolLibrary.default_symbols().</p> <code>default_symbols()</code> <p>Returns:</p> Type Description <code>callable</code> <p>An executable function that takes in a 2D array of input values <code>X</code>, a 1D array of constant values <code>C</code>, and a 1D array of target values <code>y</code>. It returns the root mean squared error between the output of the expression and the target values.</p> Source code in <code>SRToolkit/utils/expression_compiler.py</code> <pre><code>def expr_to_error_function(expr: List[str], symbol_library: SymbolLibrary=SymbolLibrary.default_symbols()) -&gt; callable:\n    \"\"\"\n    Converts an expression in infix notation to an executable function that returns the root mean squared error between\n    the output of the expression and the target values.\n\n    Examples:\n        &gt;&gt;&gt; executable_fun = expr_to_error_function([\"X_0\", \"+\", \"1\"])\n        &gt;&gt;&gt; executable_fun(np.array([[1], [2], [3], [4]]), np.array([]), np.array([2, 3, 4, 5]))\n        0.0\n\n    Args:\n        expr : The expression in infix notation.\n        symbol_library : The symbol library to use. Defaults to SymbolLibrary.default_symbols().\n\n    Returns:\n        An executable function that takes in a 2D array of input values `X`, a 1D array of constant values `C`, and a 1D array of target values `y`. It returns the root mean squared error between the output of the expression and the target values.\n    \"\"\"\n    tree = tokens_to_tree(expr, symbol_library)\n    code, symbol, var_counter, const_counter = tree_to_function_rec(tree, symbol_library)\n\n    fun_string = \"def _executable_expression_(X, C, y):\\n\"\n    for c in code:\n        fun_string += \"\\t\" + c + \"\\n\"\n    fun_string += f\"\\treturn np.sqrt(np.mean(({symbol}-y)**2))\"\n\n    exec(fun_string)\n    return locals()[\"_executable_expression_\"]\n</code></pre>"},{"location":"references/utils/expression_compiler/#SRToolkit.utils.expression_compiler.tree_to_function_rec","title":"<code>tree_to_function_rec(tree, symbol_library, var_counter=0, const_counter=0)</code>","text":"<p>Recursively converts a parse tree into a string of Python code that can be executed to evaluate the expression represented by the tree.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>The root of the parse tree to convert.</p> required <code>symbol_library</code> <code>SymbolLibrary</code> <p>The symbol library to use when converting the tree. This library defines the properties of the symbols in the tree.</p> required <code>var_counter</code> <code>int</code> <p>The number of variables encountered so far. This is used to create a unique variable name for each variable.</p> <code>0</code> <code>const_counter</code> <code>int</code> <p>The number of constants encountered so far. This is used to select the correct constant value from the constant array.</p> <code>0</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of strings, where each string contains a line of Python code to execute to evaluate the expression represented by the tree.</p> <code>str</code> <p>The name of the variable that represents the output of the expression.</p> <code>int</code> <p>The updated value of <code>var_counter</code>.</p> <code>int</code> <p>The updated value of <code>const_counter</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the parse tree contains an invalid symbol.</p> Notes <p>This function is a helper function for <code>expr_to_executable_function</code> and similar and should not be called directly unless you want to customize the way the expression is defined. For examples, see the code of <code>expr_to_executable_function</code> and <code>expr_to_error_function</code> in this module.</p> Source code in <code>SRToolkit/utils/expression_compiler.py</code> <pre><code>def tree_to_function_rec(tree: Node, symbol_library: SymbolLibrary, var_counter: int=0, const_counter: int=0) -&gt; Tuple[List[str], str, int, int]:\n    \"\"\"\n    Recursively converts a parse tree into a string of Python code that can be executed to evaluate the expression\n    represented by the tree.\n\n    Args:\n        tree: The root of the parse tree to convert.\n        symbol_library: The symbol library to use when converting the tree. This library defines the properties of the symbols in the tree.\n        var_counter: The number of variables encountered so far. This is used to create a unique variable name for each variable.\n        const_counter: The number of constants encountered so far. This is used to select the correct constant value from the constant array.\n\n    Returns:\n        A list of strings, where each string contains a line of Python code to execute to evaluate the expression represented by the tree.\n        The name of the variable that represents the output of the expression.\n        The updated value of `var_counter`.\n        The updated value of `const_counter`.\n\n    Raises:\n        Exception: If the parse tree contains an invalid symbol.\n\n    Notes:\n        This function is a helper function for `expr_to_executable_function` and similar and should not be called directly\n        unless you want to customize the way the expression is defined. For examples, see the code of `expr_to_executable_function` and `expr_to_error_function` in this module.\n\n\n    \"\"\"\n    if tree.left is None and tree.right is None:\n        if symbol_library.get_type(tree.symbol) in [\"var\", \"lit\"]:\n            return [], symbol_library.get_np_fn(tree.symbol), var_counter, const_counter\n        elif symbol_library.get_type(tree.symbol) == \"const\":\n            return [], symbol_library.get_np_fn(tree.symbol).format(const_counter), var_counter, const_counter + 1\n        else:\n            if is_float(tree.symbol):\n                return [], tree.symbol, var_counter, const_counter\n            else:\n                raise Exception(f\"Encountered invalid symbol {tree.symbol} while converting to function.\")\n\n    elif tree.left is not None and tree.right is None:\n        code, symbol, var_counter, const_counter = tree_to_function_rec(tree.left, symbol_library, var_counter, const_counter)\n        output_symbol = \"y_{}\".format(var_counter)\n        code.append(symbol_library.get_np_fn(tree.symbol).format(output_symbol, symbol))\n        return code, output_symbol, var_counter + 1, const_counter\n\n    else:\n        left_code, left_symbol, var_counter, const_counter = tree_to_function_rec(tree.left, symbol_library, var_counter, const_counter)\n        right_code, right_symbol, var_counter, const_counter = tree_to_function_rec(tree.right, symbol_library, var_counter, const_counter)\n        output_symbol = \"y_{}\".format(var_counter)\n        code = left_code + right_code\n        code.append(symbol_library.get_np_fn(tree.symbol).format(output_symbol, left_symbol, right_symbol))\n        return code, output_symbol, var_counter + 1, const_counter\n</code></pre>"},{"location":"references/utils/expression_tree/","title":"Expression Tree Module","text":""},{"location":"references/utils/expression_tree/#SRToolkit.utils.expression_tree","title":"<code>SRToolkit.utils.expression_tree</code>","text":"<p>The module containing the expression tree data structure and functions for transforming expressions into trees and back.</p>"},{"location":"references/utils/expression_tree/#SRToolkit.utils.expression_tree.Node","title":"<code>Node</code>","text":"Source code in <code>SRToolkit/utils/expression_tree.py</code> <pre><code>class Node:\n    def __init__(self, symbol: str = None, right: \"Node\" = None, left: \"Node\" = None):\n        \"\"\"\n        Initializes a Node object. We assume that nodes containing functions have only one child node, i.e. right is None.\n\n        Examples:\n            &gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n            &gt;&gt;&gt; len(node)\n            3\n\n        Args:\n            symbol: The symbol string stored in this node.\n            right: The right child of this node.\n            left: The left child of this node.\n\n        Methods:\n            __len__(self):\n                Returns the number of nodes in the tree rooted at this node.\n            __str__(self):\n                Returns a string representation of the tree rooted at this node.\n            to_list(self, notation: str = \"infix\", symbol_library: SymbolLibrary = None):\n                Returns a list representation of the tree rooted at this node.\n\n        \"\"\"\n        self.symbol = symbol\n        self.right = right\n        self.left = left\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Returns the number of nodes in the tree rooted at this node.\n\n        Examples:\n            &gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n            &gt;&gt;&gt; len(node)\n            3\n\n        Returns:\n            The number of nodes in the tree rooted at this node.\n        \"\"\"\n        return (\n            1\n            + (len(self.left) if self.left is not None else 0)\n            + (len(self.right) if self.right is not None else 0)\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a string representation of the tree rooted at this node.\n\n        Examples:\n            &gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n            &gt;&gt;&gt; str(node)\n            'x+1'\n\n        Returns:\n            A string representation of the tree rooted at this node.\n        \"\"\"\n        return \"\".join(self.to_list())\n\n    def to_list(self, notation: str = \"infix\", symbol_library: SymbolLibrary = None) -&gt; List[str]:\n        \"\"\"\n        Transforms the tree rooted at this node into a list of tokens.\n\n        Examples:\n            &gt;&gt;&gt; node = Node(\"+\", Node(\"X_0\"), Node(\"1\"))\n            &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n            ['1', '+', 'X_0']\n            &gt;&gt;&gt; node.to_list(notation=\"postfix\")\n            ['1', 'X_0', '+']\n            &gt;&gt;&gt; node.to_list(notation=\"prefix\")\n            ['+', '1', 'X_0']\n            &gt;&gt;&gt; node = Node(\"+\", Node(\"*\", Node(\"X_0\"), Node(\"X_1\")), Node(\"1\"))\n            &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n            ['1', '+', 'X_1', '*', 'X_0']\n            &gt;&gt;&gt; node.to_list(notation=\"infix\")\n            ['1', '+', '(', 'X_1', '*', 'X_0', ')']\n            &gt;&gt;&gt; node = Node(\"sin\", None, Node(\"X_0\"))\n            &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n            ['sin', '(', 'X_0', ')']\n            &gt;&gt;&gt; node = Node(\"^2\", None, Node(\"X_0\"))\n            &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n            ['X_0', '^2']\n            &gt;&gt;&gt; node.to_list()\n            ['(', 'X_0', ')', '^2']\n\n        Args:\n            notation: The notation to use for the resulting list of tokens. One of \"prefix\", \"postfix\", or \"infix\".\n            symbol_library: The symbol library to use when converting the tree. This library defines the properties of the symbols in the tree.\n\n        Returns:\n            A list of tokens representing the tree rooted at this node in the specified notation.\n\n        Raises:\n             Exception: If the notation is not one of \"prefix\", \"postfix\", or \"infix\" or if a symbol is not in the symbol library.\n\n        Notes:\n            If the notation is \"infix\" and the symbol library is not provided, then the resulting list of tokens may contain unnecessary parentheses or have other issues.\n        \"\"\"\n        left = [] if self.left is None else self.left.to_list(notation, symbol_library)\n        right = [] if self.right is None else self.right.to_list(notation, symbol_library)\n\n        if notation == \"prefix\":\n            return [self.symbol] + left + right\n\n        elif notation == \"postfix\":\n            return left + right + [self.symbol]\n\n        elif notation == \"infix\" and symbol_library is None:\n            warnings.warn(\"Symbol library not provided. Generated expression may contain unnecessary parentheses and\"\n                          \" have other issues.\")\n            if self.left is None and self.right is None:\n                return [self.symbol]\n            if self.right is None and self.left is not None:\n                if self.symbol[0] == \"^\":\n                    return [\"(\"] + left + [\")\", self.symbol]\n                else:\n                    return [self.symbol, \"(\"] + left + [\")\"]\n            else:\n                if len(left) &gt; 1:\n                    left = [\"(\"] + left + [\")\"]\n                if len(right) &gt; 1:\n                    right = [\"(\"] + right + [\")\"]\n                return left + [self.symbol] + right\n\n        elif notation == \"infix\":\n            if is_float(self.symbol):\n                return [self.symbol]\n            if symbol_library.get_type(self.symbol) in [\"var\", \"const\", \"lit\"]:\n                return [self.symbol]\n            elif symbol_library.get_type(self.symbol) == \"fn\":\n                if symbol_library.get_precedence(self.symbol) &gt; 0:\n                    return [self.symbol, \"(\"] + left + [\")\"]\n                else:\n                    if len(left) &gt; 1:\n                        left = [\"(\"] + left + [\")\"]\n                    return left + [self.symbol]\n            elif symbol_library.get_type(self.symbol) == \"op\":\n                if not is_float(self.left.symbol) and -1 &lt; symbol_library.get_precedence(self.left.symbol) &lt;= symbol_library.get_precedence(self.symbol):\n                    left = [\"(\"] + left + [\")\"]\n                if not is_float(self.right.symbol) and -1 &lt; symbol_library.get_precedence(self.right.symbol) &lt;= symbol_library.get_precedence(self.symbol):\n                    right = [\"(\"] + right + [\")\"]\n                return left + [self.symbol] + right\n            else:\n                raise Exception(f\"Invalid symbol type for symbol {self.symbol}.\")\n        else:\n            raise Exception(\"Invalid notation selected. Use 'infix', 'prefix', 'postfix', or leave blank (defaults to 'infix').\")\n</code></pre>"},{"location":"references/utils/expression_tree/#SRToolkit.utils.expression_tree.Node.__init__","title":"<code>__init__(symbol=None, right=None, left=None)</code>","text":"<p>Initializes a Node object. We assume that nodes containing functions have only one child node, i.e. right is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n&gt;&gt;&gt; len(node)\n3\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol string stored in this node.</p> <code>None</code> <code>right</code> <code>Node</code> <p>The right child of this node.</p> <code>None</code> <code>left</code> <code>Node</code> <p>The left child of this node.</p> <code>None</code> <p>Functions:</p> Name Description <code>__len__</code> <p>Returns the number of nodes in the tree rooted at this node.</p> <code>__str__</code> <p>Returns a string representation of the tree rooted at this node.</p> <code>to_list</code> <p>str = \"infix\", symbol_library: SymbolLibrary = None): Returns a list representation of the tree rooted at this node.</p> Source code in <code>SRToolkit/utils/expression_tree.py</code> <pre><code>def __init__(self, symbol: str = None, right: \"Node\" = None, left: \"Node\" = None):\n    \"\"\"\n    Initializes a Node object. We assume that nodes containing functions have only one child node, i.e. right is None.\n\n    Examples:\n        &gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n        &gt;&gt;&gt; len(node)\n        3\n\n    Args:\n        symbol: The symbol string stored in this node.\n        right: The right child of this node.\n        left: The left child of this node.\n\n    Methods:\n        __len__(self):\n            Returns the number of nodes in the tree rooted at this node.\n        __str__(self):\n            Returns a string representation of the tree rooted at this node.\n        to_list(self, notation: str = \"infix\", symbol_library: SymbolLibrary = None):\n            Returns a list representation of the tree rooted at this node.\n\n    \"\"\"\n    self.symbol = symbol\n    self.right = right\n    self.left = left\n</code></pre>"},{"location":"references/utils/expression_tree/#SRToolkit.utils.expression_tree.Node.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of nodes in the tree rooted at this node.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n&gt;&gt;&gt; len(node)\n3\n</code></pre> <p>Returns:</p> Type Description <code>int</code> <p>The number of nodes in the tree rooted at this node.</p> Source code in <code>SRToolkit/utils/expression_tree.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of nodes in the tree rooted at this node.\n\n    Examples:\n        &gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n        &gt;&gt;&gt; len(node)\n        3\n\n    Returns:\n        The number of nodes in the tree rooted at this node.\n    \"\"\"\n    return (\n        1\n        + (len(self.left) if self.left is not None else 0)\n        + (len(self.right) if self.right is not None else 0)\n    )\n</code></pre>"},{"location":"references/utils/expression_tree/#SRToolkit.utils.expression_tree.Node.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string representation of the tree rooted at this node.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n&gt;&gt;&gt; str(node)\n'x+1'\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the tree rooted at this node.</p> Source code in <code>SRToolkit/utils/expression_tree.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a string representation of the tree rooted at this node.\n\n    Examples:\n        &gt;&gt;&gt; node = Node(\"+\", Node(\"x\"), Node(\"1\"))\n        &gt;&gt;&gt; str(node)\n        'x+1'\n\n    Returns:\n        A string representation of the tree rooted at this node.\n    \"\"\"\n    return \"\".join(self.to_list())\n</code></pre>"},{"location":"references/utils/expression_tree/#SRToolkit.utils.expression_tree.Node.to_list","title":"<code>to_list(notation='infix', symbol_library=None)</code>","text":"<p>Transforms the tree rooted at this node into a list of tokens.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = Node(\"+\", Node(\"X_0\"), Node(\"1\"))\n&gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n['1', '+', 'X_0']\n&gt;&gt;&gt; node.to_list(notation=\"postfix\")\n['1', 'X_0', '+']\n&gt;&gt;&gt; node.to_list(notation=\"prefix\")\n['+', '1', 'X_0']\n&gt;&gt;&gt; node = Node(\"+\", Node(\"*\", Node(\"X_0\"), Node(\"X_1\")), Node(\"1\"))\n&gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n['1', '+', 'X_1', '*', 'X_0']\n&gt;&gt;&gt; node.to_list(notation=\"infix\")\n['1', '+', '(', 'X_1', '*', 'X_0', ')']\n&gt;&gt;&gt; node = Node(\"sin\", None, Node(\"X_0\"))\n&gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n['sin', '(', 'X_0', ')']\n&gt;&gt;&gt; node = Node(\"^2\", None, Node(\"X_0\"))\n&gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n['X_0', '^2']\n&gt;&gt;&gt; node.to_list()\n['(', 'X_0', ')', '^2']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>notation</code> <code>str</code> <p>The notation to use for the resulting list of tokens. One of \"prefix\", \"postfix\", or \"infix\".</p> <code>'infix'</code> <code>symbol_library</code> <code>SymbolLibrary</code> <p>The symbol library to use when converting the tree. This library defines the properties of the symbols in the tree.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of tokens representing the tree rooted at this node in the specified notation.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the notation is not one of \"prefix\", \"postfix\", or \"infix\" or if a symbol is not in the symbol library.</p> Notes <p>If the notation is \"infix\" and the symbol library is not provided, then the resulting list of tokens may contain unnecessary parentheses or have other issues.</p> Source code in <code>SRToolkit/utils/expression_tree.py</code> <pre><code>def to_list(self, notation: str = \"infix\", symbol_library: SymbolLibrary = None) -&gt; List[str]:\n    \"\"\"\n    Transforms the tree rooted at this node into a list of tokens.\n\n    Examples:\n        &gt;&gt;&gt; node = Node(\"+\", Node(\"X_0\"), Node(\"1\"))\n        &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n        ['1', '+', 'X_0']\n        &gt;&gt;&gt; node.to_list(notation=\"postfix\")\n        ['1', 'X_0', '+']\n        &gt;&gt;&gt; node.to_list(notation=\"prefix\")\n        ['+', '1', 'X_0']\n        &gt;&gt;&gt; node = Node(\"+\", Node(\"*\", Node(\"X_0\"), Node(\"X_1\")), Node(\"1\"))\n        &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n        ['1', '+', 'X_1', '*', 'X_0']\n        &gt;&gt;&gt; node.to_list(notation=\"infix\")\n        ['1', '+', '(', 'X_1', '*', 'X_0', ')']\n        &gt;&gt;&gt; node = Node(\"sin\", None, Node(\"X_0\"))\n        &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n        ['sin', '(', 'X_0', ')']\n        &gt;&gt;&gt; node = Node(\"^2\", None, Node(\"X_0\"))\n        &gt;&gt;&gt; node.to_list(symbol_library=SymbolLibrary.default_symbols())\n        ['X_0', '^2']\n        &gt;&gt;&gt; node.to_list()\n        ['(', 'X_0', ')', '^2']\n\n    Args:\n        notation: The notation to use for the resulting list of tokens. One of \"prefix\", \"postfix\", or \"infix\".\n        symbol_library: The symbol library to use when converting the tree. This library defines the properties of the symbols in the tree.\n\n    Returns:\n        A list of tokens representing the tree rooted at this node in the specified notation.\n\n    Raises:\n         Exception: If the notation is not one of \"prefix\", \"postfix\", or \"infix\" or if a symbol is not in the symbol library.\n\n    Notes:\n        If the notation is \"infix\" and the symbol library is not provided, then the resulting list of tokens may contain unnecessary parentheses or have other issues.\n    \"\"\"\n    left = [] if self.left is None else self.left.to_list(notation, symbol_library)\n    right = [] if self.right is None else self.right.to_list(notation, symbol_library)\n\n    if notation == \"prefix\":\n        return [self.symbol] + left + right\n\n    elif notation == \"postfix\":\n        return left + right + [self.symbol]\n\n    elif notation == \"infix\" and symbol_library is None:\n        warnings.warn(\"Symbol library not provided. Generated expression may contain unnecessary parentheses and\"\n                      \" have other issues.\")\n        if self.left is None and self.right is None:\n            return [self.symbol]\n        if self.right is None and self.left is not None:\n            if self.symbol[0] == \"^\":\n                return [\"(\"] + left + [\")\", self.symbol]\n            else:\n                return [self.symbol, \"(\"] + left + [\")\"]\n        else:\n            if len(left) &gt; 1:\n                left = [\"(\"] + left + [\")\"]\n            if len(right) &gt; 1:\n                right = [\"(\"] + right + [\")\"]\n            return left + [self.symbol] + right\n\n    elif notation == \"infix\":\n        if is_float(self.symbol):\n            return [self.symbol]\n        if symbol_library.get_type(self.symbol) in [\"var\", \"const\", \"lit\"]:\n            return [self.symbol]\n        elif symbol_library.get_type(self.symbol) == \"fn\":\n            if symbol_library.get_precedence(self.symbol) &gt; 0:\n                return [self.symbol, \"(\"] + left + [\")\"]\n            else:\n                if len(left) &gt; 1:\n                    left = [\"(\"] + left + [\")\"]\n                return left + [self.symbol]\n        elif symbol_library.get_type(self.symbol) == \"op\":\n            if not is_float(self.left.symbol) and -1 &lt; symbol_library.get_precedence(self.left.symbol) &lt;= symbol_library.get_precedence(self.symbol):\n                left = [\"(\"] + left + [\")\"]\n            if not is_float(self.right.symbol) and -1 &lt; symbol_library.get_precedence(self.right.symbol) &lt;= symbol_library.get_precedence(self.symbol):\n                right = [\"(\"] + right + [\")\"]\n            return left + [self.symbol] + right\n        else:\n            raise Exception(f\"Invalid symbol type for symbol {self.symbol}.\")\n    else:\n        raise Exception(\"Invalid notation selected. Use 'infix', 'prefix', 'postfix', or leave blank (defaults to 'infix').\")\n</code></pre>"},{"location":"references/utils/expression_tree/#SRToolkit.utils.expression_tree.is_float","title":"<code>is_float(element)</code>","text":"<p>Checks if a given element is a float.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_float(1.0)\nTrue\n&gt;&gt;&gt; is_float(\"1.0\")\nTrue\n&gt;&gt;&gt; is_float(\"1\")\nTrue\n&gt;&gt;&gt; is_float(None)\nFalse\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>any</code> <p>The element to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the element is a float, False otherwise.</p> Source code in <code>SRToolkit/utils/expression_tree.py</code> <pre><code>def is_float(element: any) -&gt; bool:\n    \"\"\"\n    Checks if a given element is a float.\n\n    Examples:\n        &gt;&gt;&gt; is_float(1.0)\n        True\n        &gt;&gt;&gt; is_float(\"1.0\")\n        True\n        &gt;&gt;&gt; is_float(\"1\")\n        True\n        &gt;&gt;&gt; is_float(None)\n        False\n\n\n    Args:\n        element: The element to check.\n\n    Returns:\n        True if the element is a float, False otherwise.\n    \"\"\"\n    if element is None:\n        return False\n    try:\n        float(element)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"references/utils/expression_tree/#SRToolkit.utils.expression_tree.tokens_to_tree","title":"<code>tokens_to_tree(tokens, sl)</code>","text":"<p>Converts a list of tokens to a tree data structure. Throws an exception if the expression is invalid (check syntax and that all symbols are in the symbol library correctly defined).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tree = tokens_to_tree([\"(\", \"x\", \"+\", \"y\", \")\"], SymbolLibrary.default_symbols())\n&gt;&gt;&gt; len(tree)\n3\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>List[str]</code> <p>The list of tokens to convert.</p> required <code>sl</code> <code>SymbolLibrary</code> <p>The symbol library to use when parsing the tokens.</p> required <p>Returns:</p> Type Description <code>Node</code> <p>The root of the expression tree data structure.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the expression is invalid. Usually this means that a symbol is not in the symbol library or that        there is a syntactic error in the expression.</p> Source code in <code>SRToolkit/utils/expression_tree.py</code> <pre><code>def tokens_to_tree(tokens: List[str], sl: SymbolLibrary) -&gt; Node:\n    \"\"\"\n    Converts a list of tokens to a tree data structure. Throws an exception if the expression is invalid (check syntax\n    and that all symbols are in the symbol library correctly defined).\n\n    Examples:\n        &gt;&gt;&gt; tree = tokens_to_tree([\"(\", \"x\", \"+\", \"y\", \")\"], SymbolLibrary.default_symbols())\n        &gt;&gt;&gt; len(tree)\n        3\n\n    Args:\n        tokens: The list of tokens to convert.\n        sl: The symbol library to use when parsing the tokens.\n\n    Returns:\n        The root of the expression tree data structure.\n\n    Raises:\n        Exception: If the expression is invalid. Usually this means that a symbol is not in the symbol library or that\n                   there is a syntactic error in the expression.\n    \"\"\"\n    num_tokens = len([t for t in tokens if t != \"(\" and t != \")\"])\n    expr_str = \"\".join(tokens)\n    tokens = [\"(\"] + tokens + [\")\"]\n    operator_stack = []\n    out_stack = []\n    for token in tokens:\n        if token == \"(\":\n            operator_stack.append(token)\n        elif sl.get_type(token) in [\"var\", \"const\", \"lit\"] or is_float(token):\n            out_stack.append(Node(token))\n        elif sl.get_type(token) == \"fn\":\n            if token[0] == \"^\":\n                out_stack.append(Node(token, left=out_stack.pop()))\n            else:\n                operator_stack.append(token)\n        elif sl.get_type(token) == \"op\":\n            while (\n                len(operator_stack) &gt; 0\n                and operator_stack[-1] != \"(\"\n                and sl.get_precedence(operator_stack[-1]) &gt; sl.get_precedence(token)\n            ):\n                if sl.get_type(operator_stack[-1]) == \"fn\":\n                    out_stack.append(Node(operator_stack.pop(), left=out_stack.pop()))\n                else:\n                    out_stack.append(\n                        Node(operator_stack.pop(), out_stack.pop(), out_stack.pop())\n                    )\n            operator_stack.append(token)\n        else:\n            while len(operator_stack) &gt; 0 and operator_stack[-1] != \"(\":\n                if sl.get_type(operator_stack[-1]) == \"fn\":\n                    out_stack.append(Node(operator_stack.pop(), left=out_stack.pop()))\n                else:\n                    out_stack.append(\n                        Node(operator_stack.pop(), out_stack.pop(), out_stack.pop())\n                    )\n            operator_stack.pop()\n            if len(operator_stack) &gt; 0 and sl.get_type(operator_stack[-1]) == \"fn\":\n                out_stack.append(Node(operator_stack.pop(), left=out_stack.pop()))\n    if len(out_stack[-1]) == num_tokens:\n        return out_stack[-1]\n    else:\n        raise Exception(f\"Error while parsing expression {expr_str}.\")\n</code></pre>"},{"location":"references/utils/symbol_library/","title":"Symbol Library Module","text":""},{"location":"references/utils/symbol_library/#SRToolkit.utils.symbol_library","title":"<code>SRToolkit.utils.symbol_library</code>","text":"<p>This module contains the SymbolLibrary class, which is used for managing symbols and their properties.</p>"},{"location":"references/utils/symbol_library/#SRToolkit.utils.symbol_library.SymbolLibrary","title":"<code>SymbolLibrary</code>","text":"Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>class SymbolLibrary:\n    def __init__(self):\n        \"\"\"\n        Initializes an instance of the SymbolLibrary class. This class is used for managing symbols and their\n        properties for other functionality in this package.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary()\n            &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; library.get_type(\"x\")\n            'var'\n            &gt;&gt;&gt; library.get_precedence(\"x\")\n            0\n            &gt;&gt;&gt; library.get_np_fn(\"x\")\n            'x'\n            &gt;&gt;&gt; library.remove_symbol(\"x\")\n            &gt;&gt;&gt; library = SymbolLibrary.default_symbols()\n\n        Attributes:\n            symbols : dict\n                A dictionary mapping symbols to their properties (type, precedence, numpy function).\n\n        Methods:\n            add_symbol(symbol, symbol_type, precedence, np_fn):\n                Adds a symbol to the library.\n            remove_symbol(symbol):\n                Removes a symbol from the library.\n            get_type(symbol):\n                Retrieves the type of a symbol from the library.\n            get_precedence(symbol):\n                Returns the precedence of the given symbol.\n            get_np_fn(symbol):\n                Returns the numpy function corresponding to the given symbol.\n            default_symbols():\n                Returns a SymbolLibrary with the default symbols.\n        \"\"\"\n        self.symbols = dict()\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a string representation of the SymbolLibrary instance.\n\n        This method provides a comma-separated string of all the symbol keys\n        currently stored in the SymbolLibrary.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary()\n            &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; str(library)\n            'x'\n            &gt;&gt;&gt; library.add_symbol(\"sin\", \"fn\", 5, \"{} = np.sin({})\")\n            &gt;&gt;&gt; str(library)\n            'x, sin'\n\n        Returns:\n            A string containing all symbols in the library, separated by commas.\n        \"\"\"\n        return \", \".join(self.symbols.keys())\n\n    def __copy__(self) -&gt; \"SymbolLibrary\":\n        \"\"\"\n        Creates a copy of the SymbolLibrary instance.\n\n        Examples:\n            &gt;&gt;&gt; old_symbols = SymbolLibrary()\n            &gt;&gt;&gt; old_symbols.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; print(old_symbols)\n            x\n            &gt;&gt;&gt; new_symbols = copy.copy(old_symbols)\n            &gt;&gt;&gt; new_symbols.add_symbol(\"sin\", \"fn\", 5, \"{} = np.sin({})\")\n            &gt;&gt;&gt; print(old_symbols)\n            x\n            &gt;&gt;&gt; print(new_symbols)\n            x, sin\n\n        Returns:\n            A copy of the SymbolLibrary instance.\n        \"\"\"\n        sl = SymbolLibrary()\n        sl.symbols = copy.deepcopy(self.symbols)\n        return sl\n\n    def add_symbol(self, symbol: str, symbol_type: str, precedence: int, np_fn: str):\n        \"\"\"\n        Adds a symbol to the library. A symbol should have a type, precedence, and numpy function associated with it.\n        Type \"op\" should be used for symbols operating on two operands, \"fn\" for symbols operating on one operand,\n        \"lit\" for constants with a known value (such as pi or e), \"const\" for constants/parameters without a value that\n        need to be optimized, and \"var\" for variables whose values are provided as input data.\n\n        For example, look at the default_symbols function for the SymbolLibrary class.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary()\n            &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; library.add_symbol(\"sin\", \"fn\", 5, \"np.sin({})\")\n            &gt;&gt;&gt; library.add_symbol(\"C\", \"const\", 5, \"C[{}]\")\n            &gt;&gt;&gt; library.add_symbol(\"X\", \"var\", 5, \"X[:, 0]\")\n            &gt;&gt;&gt; library.add_symbol(\"pi\", \"lit\", 5, \"np.pi\")\n\n        Args:\n            symbol: The symbol to be added to the library.\n            symbol_type: The type of the symbol, one of \"op\" (operator), \"fn\" (function), \"lit\" (literal), \"const\" (constant), or \"var\" (variable).\n            precedence: The precedence of the symbol, used to determine the order of operations.\n            np_fn: A string representing the numpy function associated with this symbol.\n        \"\"\"\n        self.symbols[symbol] = {\n            \"symbol\": symbol,\n            \"type\": symbol_type,\n            \"precedence\": precedence,\n            \"np_fn\": np_fn,\n        }\n\n    def remove_symbol(self, symbol: str):\n        \"\"\"\n        Removes a symbol from the library.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary()\n            &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; len(library.symbols)\n            1\n            &gt;&gt;&gt; library.remove_symbol(\"x\")\n            &gt;&gt;&gt; len(library.symbols)\n            0\n\n        Args:\n            symbol: The symbol to be removed from the library.\n\n        Raises:\n            KeyError: If the symbol does not exist in the library.\n        \"\"\"\n        del self.symbols[symbol]\n\n    def get_type(self, symbol: str) -&gt; str:\n        \"\"\"\n        Retrieves the type of a symbol from the library.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary()\n            &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; library.get_type(\"x\")\n            'var'\n\n        Args:\n            symbol: The symbol whose type is to be retrieved.\n\n        Returns:\n            The type of the symbol if it exists in the library, otherwise an empty string.\n        \"\"\"\n        if symbol in self.symbols:\n            return self.symbols[symbol][\"type\"]\n        else:\n            return \"\"\n\n    def get_precedence(self, symbol: str) -&gt; int:\n        \"\"\"\n        Retrieves the precedence of the given symbol.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary()\n            &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; library.get_precedence(\"x\")\n            0\n\n        Args:\n            symbol: The symbol whose precedence is to be retrieved.\n\n        Returns:\n            The precedence of the symbol if it exists in the library, otherwise -1.\n        \"\"\"\n        if symbol in self.symbols:\n            return self.symbols[symbol][\"precedence\"]\n        else:\n            return -1\n\n    def get_np_fn(self, symbol: str) -&gt; str:\n        \"\"\"\n        Returns the numpy function corresponding to the given symbol.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary()\n            &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n            &gt;&gt;&gt; library.get_np_fn(\"x\")\n            'x'\n\n        Args:\n            symbol: The symbol to look up.\n\n        Returns:\n            The numpy function corresponding to the given symbol, or an empty string if the symbol was not found.\n        \"\"\"\n        if symbol in self.symbols:\n            return self.symbols[symbol][\"np_fn\"]\n        else:\n            return \"\"\n\n    @staticmethod\n    def default_symbols(num_variables: int = 25) -&gt; \"SymbolLibrary\":\n        \"\"\"\n        Creates a SymbolLibrary instance populated with default mathematical symbols.\n\n        This method adds a set of predefined symbols to a SymbolLibrary instance,\n        representing common mathematical operations, functions, constants, and optional\n        variables. The symbols include basic arithmetic operations, trigonometric and\n        exponential functions, and mathematical constants like pi and e.\n\n        If num_variables is greater than 0, it adds variables labeled 'X_0' to 'X_{num_variables-1}', each\n         associated with a column in a data array X.\n\n        Note: The variables in the default_symbols function are added in the predefined order,\n        which is the same order as the columns in the data array X.\n\n        Examples:\n            &gt;&gt;&gt; library = SymbolLibrary.default_symbols()\n            &gt;&gt;&gt; len(library.symbols)\n            44\n\n        Args:\n            num_variables: The number of variables to add to the library (default is 25).\n\n        Returns:\n            A SymbolLibrary instance populated with default mathematical symbols.\n        \"\"\"\n        sl = SymbolLibrary()\n        sl.add_symbol(\"+\", symbol_type=\"op\", precedence=0, np_fn=\"{} = {} + {}\")\n        sl.add_symbol(\"-\", symbol_type=\"op\", precedence=0, np_fn=\"{} = {} - {}\")\n        sl.add_symbol(\"*\", symbol_type=\"op\", precedence=1, np_fn=\"{} = {} * {}\")\n        sl.add_symbol(\"/\", symbol_type=\"op\", precedence=1, np_fn=\"{} = {} / {}\")\n        sl.add_symbol(\"^\", symbol_type=\"op\", precedence=2, np_fn=\"{} = np.pow({},{})\")\n        sl.add_symbol(\"u-\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = -{}\")\n        sl.add_symbol(\"sqrt\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.sqrt({})\")\n        sl.add_symbol(\"sin\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.sin({})\")\n        sl.add_symbol(\"cos\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.cos({})\")\n        sl.add_symbol(\"exp\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.exp({})\")\n        sl.add_symbol(\"ln\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.log({})\")\n        sl.add_symbol(\"log\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.log10({})\")\n        sl.add_symbol(\"^-1\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = 1/{}\")\n        sl.add_symbol(\"^2\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**2\")\n        sl.add_symbol(\"^3\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**3\")\n        sl.add_symbol(\"^4\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**4\")\n        sl.add_symbol(\"^5\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**5\")\n        sl.add_symbol(\"pi\", symbol_type=\"lit\", precedence=5, np_fn=\"np.pi\")\n        sl.add_symbol(\"e\", symbol_type=\"lit\", precedence=5, np_fn=\"np.e\")\n        sl.add_symbol(\"C\", symbol_type=\"const\", precedence=5, np_fn=\"C[{}]\")\n\n        if num_variables &gt; 0:\n            for i in range(num_variables):\n                sl.add_symbol(f\"X_{i}\", \"var\", 5, \"X[:, {}]\".format(i))\n\n        return sl\n</code></pre>"},{"location":"references/utils/symbol_library/#SRToolkit.utils.symbol_library.SymbolLibrary.__init__","title":"<code>__init__()</code>","text":"<p>Initializes an instance of the SymbolLibrary class. This class is used for managing symbols and their properties for other functionality in this package.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary()\n&gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; library.get_type(\"x\")\n'var'\n&gt;&gt;&gt; library.get_precedence(\"x\")\n0\n&gt;&gt;&gt; library.get_np_fn(\"x\")\n'x'\n&gt;&gt;&gt; library.remove_symbol(\"x\")\n&gt;&gt;&gt; library = SymbolLibrary.default_symbols()\n</code></pre> <p>Attributes:</p> Name Type Description <code>symbols</code> <p>dict A dictionary mapping symbols to their properties (type, precedence, numpy function).</p> <p>Functions:</p> Name Description <code>add_symbol</code> <p>Adds a symbol to the library.</p> <code>remove_symbol</code> <p>Removes a symbol from the library.</p> <code>get_type</code> <p>Retrieves the type of a symbol from the library.</p> <code>get_precedence</code> <p>Returns the precedence of the given symbol.</p> <code>get_np_fn</code> <p>Returns the numpy function corresponding to the given symbol.</p> <code>default_symbols</code> <p>Returns a SymbolLibrary with the default symbols.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes an instance of the SymbolLibrary class. This class is used for managing symbols and their\n    properties for other functionality in this package.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary()\n        &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; library.get_type(\"x\")\n        'var'\n        &gt;&gt;&gt; library.get_precedence(\"x\")\n        0\n        &gt;&gt;&gt; library.get_np_fn(\"x\")\n        'x'\n        &gt;&gt;&gt; library.remove_symbol(\"x\")\n        &gt;&gt;&gt; library = SymbolLibrary.default_symbols()\n\n    Attributes:\n        symbols : dict\n            A dictionary mapping symbols to their properties (type, precedence, numpy function).\n\n    Methods:\n        add_symbol(symbol, symbol_type, precedence, np_fn):\n            Adds a symbol to the library.\n        remove_symbol(symbol):\n            Removes a symbol from the library.\n        get_type(symbol):\n            Retrieves the type of a symbol from the library.\n        get_precedence(symbol):\n            Returns the precedence of the given symbol.\n        get_np_fn(symbol):\n            Returns the numpy function corresponding to the given symbol.\n        default_symbols():\n            Returns a SymbolLibrary with the default symbols.\n    \"\"\"\n    self.symbols = dict()\n</code></pre>"},{"location":"references/utils/symbol_library/#SRToolkit.utils.symbol_library.SymbolLibrary.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string representation of the SymbolLibrary instance.</p> <p>This method provides a comma-separated string of all the symbol keys currently stored in the SymbolLibrary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary()\n&gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; str(library)\n'x'\n&gt;&gt;&gt; library.add_symbol(\"sin\", \"fn\", 5, \"{} = np.sin({})\")\n&gt;&gt;&gt; str(library)\n'x, sin'\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>A string containing all symbols in the library, separated by commas.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a string representation of the SymbolLibrary instance.\n\n    This method provides a comma-separated string of all the symbol keys\n    currently stored in the SymbolLibrary.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary()\n        &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; str(library)\n        'x'\n        &gt;&gt;&gt; library.add_symbol(\"sin\", \"fn\", 5, \"{} = np.sin({})\")\n        &gt;&gt;&gt; str(library)\n        'x, sin'\n\n    Returns:\n        A string containing all symbols in the library, separated by commas.\n    \"\"\"\n    return \", \".join(self.symbols.keys())\n</code></pre>"},{"location":"references/utils/symbol_library/#SRToolkit.utils.symbol_library.SymbolLibrary.__copy__","title":"<code>__copy__()</code>","text":"<p>Creates a copy of the SymbolLibrary instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; old_symbols = SymbolLibrary()\n&gt;&gt;&gt; old_symbols.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; print(old_symbols)\nx\n&gt;&gt;&gt; new_symbols = copy.copy(old_symbols)\n&gt;&gt;&gt; new_symbols.add_symbol(\"sin\", \"fn\", 5, \"{} = np.sin({})\")\n&gt;&gt;&gt; print(old_symbols)\nx\n&gt;&gt;&gt; print(new_symbols)\nx, sin\n</code></pre> <p>Returns:</p> Type Description <code>SymbolLibrary</code> <p>A copy of the SymbolLibrary instance.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def __copy__(self) -&gt; \"SymbolLibrary\":\n    \"\"\"\n    Creates a copy of the SymbolLibrary instance.\n\n    Examples:\n        &gt;&gt;&gt; old_symbols = SymbolLibrary()\n        &gt;&gt;&gt; old_symbols.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; print(old_symbols)\n        x\n        &gt;&gt;&gt; new_symbols = copy.copy(old_symbols)\n        &gt;&gt;&gt; new_symbols.add_symbol(\"sin\", \"fn\", 5, \"{} = np.sin({})\")\n        &gt;&gt;&gt; print(old_symbols)\n        x\n        &gt;&gt;&gt; print(new_symbols)\n        x, sin\n\n    Returns:\n        A copy of the SymbolLibrary instance.\n    \"\"\"\n    sl = SymbolLibrary()\n    sl.symbols = copy.deepcopy(self.symbols)\n    return sl\n</code></pre>"},{"location":"references/utils/symbol_library/#SRToolkit.utils.symbol_library.SymbolLibrary.add_symbol","title":"<code>add_symbol(symbol, symbol_type, precedence, np_fn)</code>","text":"<p>Adds a symbol to the library. A symbol should have a type, precedence, and numpy function associated with it. Type \"op\" should be used for symbols operating on two operands, \"fn\" for symbols operating on one operand, \"lit\" for constants with a known value (such as pi or e), \"const\" for constants/parameters without a value that need to be optimized, and \"var\" for variables whose values are provided as input data.</p> <p>For example, look at the default_symbols function for the SymbolLibrary class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary()\n&gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; library.add_symbol(\"sin\", \"fn\", 5, \"np.sin({})\")\n&gt;&gt;&gt; library.add_symbol(\"C\", \"const\", 5, \"C[{}]\")\n&gt;&gt;&gt; library.add_symbol(\"X\", \"var\", 5, \"X[:, 0]\")\n&gt;&gt;&gt; library.add_symbol(\"pi\", \"lit\", 5, \"np.pi\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol to be added to the library.</p> required <code>symbol_type</code> <code>str</code> <p>The type of the symbol, one of \"op\" (operator), \"fn\" (function), \"lit\" (literal), \"const\" (constant), or \"var\" (variable).</p> required <code>precedence</code> <code>int</code> <p>The precedence of the symbol, used to determine the order of operations.</p> required <code>np_fn</code> <code>str</code> <p>A string representing the numpy function associated with this symbol.</p> required Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def add_symbol(self, symbol: str, symbol_type: str, precedence: int, np_fn: str):\n    \"\"\"\n    Adds a symbol to the library. A symbol should have a type, precedence, and numpy function associated with it.\n    Type \"op\" should be used for symbols operating on two operands, \"fn\" for symbols operating on one operand,\n    \"lit\" for constants with a known value (such as pi or e), \"const\" for constants/parameters without a value that\n    need to be optimized, and \"var\" for variables whose values are provided as input data.\n\n    For example, look at the default_symbols function for the SymbolLibrary class.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary()\n        &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; library.add_symbol(\"sin\", \"fn\", 5, \"np.sin({})\")\n        &gt;&gt;&gt; library.add_symbol(\"C\", \"const\", 5, \"C[{}]\")\n        &gt;&gt;&gt; library.add_symbol(\"X\", \"var\", 5, \"X[:, 0]\")\n        &gt;&gt;&gt; library.add_symbol(\"pi\", \"lit\", 5, \"np.pi\")\n\n    Args:\n        symbol: The symbol to be added to the library.\n        symbol_type: The type of the symbol, one of \"op\" (operator), \"fn\" (function), \"lit\" (literal), \"const\" (constant), or \"var\" (variable).\n        precedence: The precedence of the symbol, used to determine the order of operations.\n        np_fn: A string representing the numpy function associated with this symbol.\n    \"\"\"\n    self.symbols[symbol] = {\n        \"symbol\": symbol,\n        \"type\": symbol_type,\n        \"precedence\": precedence,\n        \"np_fn\": np_fn,\n    }\n</code></pre>"},{"location":"references/utils/symbol_library/#SRToolkit.utils.symbol_library.SymbolLibrary.remove_symbol","title":"<code>remove_symbol(symbol)</code>","text":"<p>Removes a symbol from the library.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary()\n&gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; len(library.symbols)\n1\n&gt;&gt;&gt; library.remove_symbol(\"x\")\n&gt;&gt;&gt; len(library.symbols)\n0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol to be removed from the library.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the symbol does not exist in the library.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def remove_symbol(self, symbol: str):\n    \"\"\"\n    Removes a symbol from the library.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary()\n        &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; len(library.symbols)\n        1\n        &gt;&gt;&gt; library.remove_symbol(\"x\")\n        &gt;&gt;&gt; len(library.symbols)\n        0\n\n    Args:\n        symbol: The symbol to be removed from the library.\n\n    Raises:\n        KeyError: If the symbol does not exist in the library.\n    \"\"\"\n    del self.symbols[symbol]\n</code></pre>"},{"location":"references/utils/symbol_library/#SRToolkit.utils.symbol_library.SymbolLibrary.get_type","title":"<code>get_type(symbol)</code>","text":"<p>Retrieves the type of a symbol from the library.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary()\n&gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; library.get_type(\"x\")\n'var'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol whose type is to be retrieved.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The type of the symbol if it exists in the library, otherwise an empty string.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def get_type(self, symbol: str) -&gt; str:\n    \"\"\"\n    Retrieves the type of a symbol from the library.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary()\n        &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; library.get_type(\"x\")\n        'var'\n\n    Args:\n        symbol: The symbol whose type is to be retrieved.\n\n    Returns:\n        The type of the symbol if it exists in the library, otherwise an empty string.\n    \"\"\"\n    if symbol in self.symbols:\n        return self.symbols[symbol][\"type\"]\n    else:\n        return \"\"\n</code></pre>"},{"location":"references/utils/symbol_library/#SRToolkit.utils.symbol_library.SymbolLibrary.get_precedence","title":"<code>get_precedence(symbol)</code>","text":"<p>Retrieves the precedence of the given symbol.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary()\n&gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; library.get_precedence(\"x\")\n0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol whose precedence is to be retrieved.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The precedence of the symbol if it exists in the library, otherwise -1.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def get_precedence(self, symbol: str) -&gt; int:\n    \"\"\"\n    Retrieves the precedence of the given symbol.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary()\n        &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; library.get_precedence(\"x\")\n        0\n\n    Args:\n        symbol: The symbol whose precedence is to be retrieved.\n\n    Returns:\n        The precedence of the symbol if it exists in the library, otherwise -1.\n    \"\"\"\n    if symbol in self.symbols:\n        return self.symbols[symbol][\"precedence\"]\n    else:\n        return -1\n</code></pre>"},{"location":"references/utils/symbol_library/#SRToolkit.utils.symbol_library.SymbolLibrary.get_np_fn","title":"<code>get_np_fn(symbol)</code>","text":"<p>Returns the numpy function corresponding to the given symbol.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary()\n&gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n&gt;&gt;&gt; library.get_np_fn(\"x\")\n'x'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol to look up.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The numpy function corresponding to the given symbol, or an empty string if the symbol was not found.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>def get_np_fn(self, symbol: str) -&gt; str:\n    \"\"\"\n    Returns the numpy function corresponding to the given symbol.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary()\n        &gt;&gt;&gt; library.add_symbol(\"x\", \"var\", 0, \"x\")\n        &gt;&gt;&gt; library.get_np_fn(\"x\")\n        'x'\n\n    Args:\n        symbol: The symbol to look up.\n\n    Returns:\n        The numpy function corresponding to the given symbol, or an empty string if the symbol was not found.\n    \"\"\"\n    if symbol in self.symbols:\n        return self.symbols[symbol][\"np_fn\"]\n    else:\n        return \"\"\n</code></pre>"},{"location":"references/utils/symbol_library/#SRToolkit.utils.symbol_library.SymbolLibrary.default_symbols","title":"<code>default_symbols(num_variables=25)</code>  <code>staticmethod</code>","text":"<p>Creates a SymbolLibrary instance populated with default mathematical symbols.</p> <p>This method adds a set of predefined symbols to a SymbolLibrary instance, representing common mathematical operations, functions, constants, and optional variables. The symbols include basic arithmetic operations, trigonometric and exponential functions, and mathematical constants like pi and e.</p> <p>If num_variables is greater than 0, it adds variables labeled 'X_0' to 'X_{num_variables-1}', each  associated with a column in a data array X.</p> <p>Note: The variables in the default_symbols function are added in the predefined order, which is the same order as the columns in the data array X.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; library = SymbolLibrary.default_symbols()\n&gt;&gt;&gt; len(library.symbols)\n44\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>num_variables</code> <code>int</code> <p>The number of variables to add to the library (default is 25).</p> <code>25</code> <p>Returns:</p> Type Description <code>SymbolLibrary</code> <p>A SymbolLibrary instance populated with default mathematical symbols.</p> Source code in <code>SRToolkit/utils/symbol_library.py</code> <pre><code>@staticmethod\ndef default_symbols(num_variables: int = 25) -&gt; \"SymbolLibrary\":\n    \"\"\"\n    Creates a SymbolLibrary instance populated with default mathematical symbols.\n\n    This method adds a set of predefined symbols to a SymbolLibrary instance,\n    representing common mathematical operations, functions, constants, and optional\n    variables. The symbols include basic arithmetic operations, trigonometric and\n    exponential functions, and mathematical constants like pi and e.\n\n    If num_variables is greater than 0, it adds variables labeled 'X_0' to 'X_{num_variables-1}', each\n     associated with a column in a data array X.\n\n    Note: The variables in the default_symbols function are added in the predefined order,\n    which is the same order as the columns in the data array X.\n\n    Examples:\n        &gt;&gt;&gt; library = SymbolLibrary.default_symbols()\n        &gt;&gt;&gt; len(library.symbols)\n        44\n\n    Args:\n        num_variables: The number of variables to add to the library (default is 25).\n\n    Returns:\n        A SymbolLibrary instance populated with default mathematical symbols.\n    \"\"\"\n    sl = SymbolLibrary()\n    sl.add_symbol(\"+\", symbol_type=\"op\", precedence=0, np_fn=\"{} = {} + {}\")\n    sl.add_symbol(\"-\", symbol_type=\"op\", precedence=0, np_fn=\"{} = {} - {}\")\n    sl.add_symbol(\"*\", symbol_type=\"op\", precedence=1, np_fn=\"{} = {} * {}\")\n    sl.add_symbol(\"/\", symbol_type=\"op\", precedence=1, np_fn=\"{} = {} / {}\")\n    sl.add_symbol(\"^\", symbol_type=\"op\", precedence=2, np_fn=\"{} = np.pow({},{})\")\n    sl.add_symbol(\"u-\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = -{}\")\n    sl.add_symbol(\"sqrt\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.sqrt({})\")\n    sl.add_symbol(\"sin\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.sin({})\")\n    sl.add_symbol(\"cos\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.cos({})\")\n    sl.add_symbol(\"exp\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.exp({})\")\n    sl.add_symbol(\"ln\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.log({})\")\n    sl.add_symbol(\"log\", symbol_type=\"fn\", precedence=5, np_fn=\"{} = np.log10({})\")\n    sl.add_symbol(\"^-1\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = 1/{}\")\n    sl.add_symbol(\"^2\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**2\")\n    sl.add_symbol(\"^3\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**3\")\n    sl.add_symbol(\"^4\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**4\")\n    sl.add_symbol(\"^5\", symbol_type=\"fn\", precedence=-1, np_fn=\"{} = {}**5\")\n    sl.add_symbol(\"pi\", symbol_type=\"lit\", precedence=5, np_fn=\"np.pi\")\n    sl.add_symbol(\"e\", symbol_type=\"lit\", precedence=5, np_fn=\"np.e\")\n    sl.add_symbol(\"C\", symbol_type=\"const\", precedence=5, np_fn=\"C[{}]\")\n\n    if num_variables &gt; 0:\n        for i in range(num_variables):\n            sl.add_symbol(f\"X_{i}\", \"var\", 5, \"X[:, {}]\".format(i))\n\n    return sl\n</code></pre>"}]}